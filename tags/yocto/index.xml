<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Yocto - Tag - All about IoT</title><link>https://blog.humminglab.io/tags/yocto/</link><description>Yocto - Tag - All about IoT</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 07 Jun 2022 09:00:00 +0900</lastBuildDate><atom:link href="https://blog.humminglab.io/tags/yocto/" rel="self" type="application/rss+xml"/><item><title>Systemd의 특징과 Yocto에 적용하기</title><link>https://blog.humminglab.io/posts/yocto-systemd/</link><pubDate>Tue, 07 Jun 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-systemd/</guid><description>Yocto project에서 기본 설정으로 빌드하면 SysV Init를 사용한다. 개발하는 제품이 이더넷 네트워크로 연결되고, 부팅 이후에는 네트워크 환경이 변하지 않는다면 SysV Init를 이용하는 것이 구조도 단순해서 더 좋을 수 있다.
하지만 다음과 같은 사항을 고려하고 있다면 systemd를 적용하는 것을 검토해 볼 수 있다.
Daemon 이 죽는 경우를 검출하여 재시작 관리가 필요한 경우 Wi-Fi 와 같이 동적으로 변경될 수 있는 네트워크 관리가 필요한 경우 불규칙하게 네트워크가 끊길 수 있는 조건에서 시간 동기화가 필요한 경우 프로그램에 CPU 또는 메모리 자원을 제한하기 위하여 cgroups를 사용하려는 경우 효과적인 로그 관리를 위하여 journald를 사용하고 싶은 경우 부팅 직후 초기 프로세스의 실행 시간을 줄여 보려는 경우 물론 위의 기능을 사용하기 위해서 systemd만 가능한 것은 아니지만, systemd를 사용하는 경우 별도의 프로그램 없이 위 기능을 쉽게 적용할 수 있다.</description></item><item><title>Syslog and Journald</title><link>https://blog.humminglab.io/posts/syslog-journald/</link><pubDate>Fri, 27 May 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/syslog-journald/</guid><description>대부분의 최신 linux 배포본에서 systemd를 적용하면서 로그 시스템도 syslog 에서 systemd 의 journald로 변경되었다.
PC급 이상의 linux 배포본에서는 journald와 기존 호환성을 고려하여 syslog 데몬이 같이 사용하도록 기본 설정되어 있고, 상대적으로 광활한 저장장치과 메모리를 가지고 있고, 적절한 용량 선에서 log rotate가 되도록 설정되어 있어, 사용자가 설치 후 로그에 대해서는 신경을 쓸 필요가 거의 없다.
하지만 용량이 작은 저장장치와 메모리를 가진 embedded linux 제품을 개발하는 경우에는 시스템 로그를 어떤 식으로 관리 할지 충분히 고민하고 설정하여야 한다.</description></item><item><title>Yocto에 OSTree upgrade 적용(3) - 업그레이드/롤백 및 OSTree 리뷰</title><link>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-3/</link><pubDate>Wed, 16 Feb 2022 22:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-3/</guid><description>이전글 Yocto에 OSTree upgrade 적용(1) 에서 Yocto를 이용한 빌드 과정과, Yocto에 OSTree upgrade 적용(2) 에서 OSTree를 적용한 이미지의 부팅 과정에 대해서 설명하였다.
이번 글에서는 OSTree가 적용된 이미지를 실제로 업그레이드 하는 방법, 롤백 절차, 프로그램에서 이를 관리하는 방법에 대해서 설명한다.
이해를 돕고자 OSTree의 업그레이드 절차를 git과 비교하여 설명한다. OSTree는 ostree CLI 명령을 이용하여 업그레이드 과정을 수행할 수 있고, libostree library 를 이용하여 프로그램으로 구현할 수 도 있다. 이 글에서는 CLI를 이용하는 업그레이드 방법을 설명한다.</description></item><item><title>Yocto에 OSTree upgrade 적용(2) - 부팅 절차</title><link>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-2/</link><pubDate>Mon, 14 Feb 2022 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-2/</guid><description>이전글 Yocto에 OSTree upgrade 적용(1) - 이미지 생성 에서는 Yocto 빌드 과정을 통한 target 에 write 할 이미지를 만드는 과정까지 설명 하였다.
이번글에서는 부팅 이미지를 이용하여 부팅 절차를 설명한다.
디스크 이미지 파일최종적으로 디스크에 쓰는 이미지를 Yocto 의 wic 툴을 이용하여 확인해 보면 다음과 같이 두개의 partition 으로 구성된다.
Partiton 1(fat16): DOS FAT16 의 부팅 디스크로 u-boot 과 부팅에 필요한 설정 파일이 있다. 파일 중 boot.scr 파일이 있는데, 이 파일로 u-boot 의 script를 대체하여 OSTree 이미지가 로드되도록 한다.</description></item><item><title>Yocto에 OSTree upgrade 적용(1) - 이미지 생성</title><link>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-1/</link><pubDate>Wed, 26 Jan 2022 21:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-ostree-meta-updater-1/</guid><description>Linux PC 의 경우 각 배포본 마다 yum, rpm, dpkg 등의 package manager를 제공하여, 이를 이용하여 패키지를 최신 버전으로 유지 관리할 수 있다. 임베디드의 경우도 Raspberry Pi OS, armbian 은 PC 에서 사용하는 package manager 방식을 제공하고, Yocto 도 rpm 등을 이용하여 패키지 관리가 가능하다.
이들 패키지 매니저는 패키지 데이타베이스를 업데이트 하고, 패키지 업그레이드 시 의존성 있는 추가 패키지도 다운로드 받아서 설치/삭제하고, 설치 전/후처리를 위한 script를 자동으로 실행시켜서 최종 상태를 만들어 준다.</description></item><item><title>Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기</title><link>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-3/</link><pubDate>Tue, 18 Jan 2022 23:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-3/</guid><description>Yocto Project 개발 절차는 기본적으로 이미 개발이 완료된 패키지들의 recipe를 만들고, 이를 bitbake로 전체 이미지를 빌드하는 과정이다.
하지만 개발 진행 중인 소프트웨어 패키지를 yocto에 추가하고, 이를 계속 수정 개발을 할 때 어떤 방식으로 관리를 할지 고민을 하여야 한다. 여기에서는 이와 같이 개발 중인 패키지를 yocto 에 추가하여 빌드 하는 방법을 알아본다.
Yocto Project 개발하기(1) - Orange Pi 보드 빌드 Yocto Project 개발하기(2) - Custom Layer 만들기 Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기 Yocto Project 개발하기(4) - Yocto SDK 빌드 Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델 방법들예를 들어 u-boot 를 수정 하는 경우를 예로 들어 보자.</description></item><item><title>Yocto Project 개발하기(2) - Custom Layer 만들기</title><link>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/</link><pubDate>Fri, 07 Jan 2022 19:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/</guid><description>이전 글 에서 meta-sunxi 를 추가하여 orage pi 용으로 빌드를 만들었고, 이번 과정은 project 용으로 meta layer를 만들어서 관리하는 방법을 설명한다.
실제 개발 과정을 이해하기 좋도록 meta layer 를 만들어 가는 과정을 설명한다.
Yocto Project 개발하기(1) - Orange Pi 보드 빌드 Yocto Project 개발하기(2) - Custom Layer 만들기 Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기 Yocto Project 개발하기(4) - Yocto SDK 빌드 Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델 Layer 및 machine 생성프로젝트를 sc-gateway 라고 명하고(이름에 특별한 의미는 없음), 이를 layer로 만든다.</description></item><item><title>Yocto Project 개발하기(1) - Orange Pi 보드 빌드</title><link>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/</link><pubDate>Thu, 30 Dec 2021 22:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-1/</guid><description>이 문서는 Orange Pi Zero 보드에서 Yocto Project를 이용하여 배포본을 만들고, 개별 패키지를 관리하는 방법에 대하여 설명한다.
설명은 다음과 같이 나누어서 설명을 할 예정이다.
Yocto Project 개발하기(1) - Orange Pi 보드 빌드 Yocto Project 개발하기(2) - Custom Layer 만들기 Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기 Yocto Project 개발하기(4) - Yocto SDK 빌드 Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델 이 문서에서는 첫번째 과정인 필요한 layer를 추가해서 빌드하여 타겟에 올려서 동작을 확인하는 과정을 설명한다.</description></item><item><title>Yocto Project History</title><link>https://blog.humminglab.io/posts/yocto-project-history/</link><pubDate>Sun, 06 Jan 2019 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-history/</guid><description>Yocto Project를 보면 OpenEmbedded, bitbake, poky 와 같은 용어들이 나온다. Bitbake는 Yocto Project의 make 툴이라고 이해하면 되는데, 다른 용어는 어떤 의미 인지 모호할 수 있다. OpenEmbedded와 Yocto Project와의 관계는 어떤 것인지, Poky는 범위가 어떤 것인지 메뉴얼을 보아도 정확히 감을 잡기가 어렵다.
개념적으로 잘 정리된 관계는 Yocto Project Overview and Concepts Manual, 2.1 What is the Yocto Proejct?&amp;quot;에 있는 아래 그림이다.
Yocto Elements 우선은 이를 이해하기 위하여는 Yocto Project가 발전한 변천사를 보는 것이 좋다.</description></item></channel></rss>