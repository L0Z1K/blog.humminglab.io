<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title class=pjax-title>TLS/암호 알고리즘 쉽게 이해하기(10) - Hash - All about IoT</title><meta name=Description content><meta property="og:title" content="TLS/암호 알고리즘 쉽게 이해하기(10) - Hash"><meta property="og:description" content="Hash 함수란 임의의 길이의 데이타를 축약하여 고정된 길이의 데이타로 매핑하는 함수를 말한다.
데이타 검색을 위한 hash 함수, 데이타 손상을 검출하기 위한 CRC32 도 hash 함수 이지만, 이 글에서 언급하는 것은 암호화 해시 함수이다.
각 용도에 따라서 해시 함수의 특성은 다음처럼 다를 수 있다.
데이터 검색용: 모든 입력 데이타에 대해서 hash 결과값이 균등 분포를 가져야 한다. 데이타 손상 검출용: 원하는 비트 개수 까지의 오류에 대해서 정확히 검출되어야 하고, 알고리즘에 따라서 제한된 비트 개수 까지 오류 복원이 가능하여야 한다."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.humminglab.io/posts/tls-cryptography-10-hash/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-16T09:00:00+09:00"><meta property="article:modified_time" content="2022-06-16T10:00:00+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="TLS/암호 알고리즘 쉽게 이해하기(10) - Hash"><meta name=twitter:description content="Hash 함수란 임의의 길이의 데이타를 축약하여 고정된 길이의 데이타로 매핑하는 함수를 말한다.
데이타 검색을 위한 hash 함수, 데이타 손상을 검출하기 위한 CRC32 도 hash 함수 이지만, 이 글에서 언급하는 것은 암호화 해시 함수이다.
각 용도에 따라서 해시 함수의 특성은 다음처럼 다를 수 있다.
데이터 검색용: 모든 입력 데이타에 대해서 hash 결과값이 균등 분포를 가져야 한다. 데이타 손상 검출용: 원하는 비트 개수 까지의 오류에 대해서 정확히 검출되어야 하고, 알고리즘에 따라서 제한된 비트 개수 까지 오류 복원이 가능하여야 한다."><meta name=application-name content="All about IoT"><meta name=apple-mobile-web-app-title content="All about IoT"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://blog.humminglab.io/posts/tls-cryptography-10-hash/><link rel=prev href=https://blog.humminglab.io/posts/tls-cryptography-9-dsa/><link rel=next href=https://blog.humminglab.io/posts/tls-cryptography-11-ecc/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"TLS/암호 알고리즘 쉽게 이해하기(10) - Hash","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.humminglab.io\/posts\/tls-cryptography-10-hash\/"},"genre":"posts","keywords":"Cryptography, MD5, SHA, BLAKE2","wordcount":1427,"url":"https:\/\/blog.humminglab.io\/posts\/tls-cryptography-10-hash\/","datePublished":"2022-04-16T09:00:00+09:00","dateModified":"2022-06-16T10:00:00+09:00","publisher":{"@type":"Organization","name":"HummingLab"},"authors":[{"@type":"Person","name":"YSLee"}],"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>function setTheme(e){document.body.setAttribute('theme',e)}function saveTheme(e){window.localStorage&&localStorage.setItem('theme',e)}function getMeta(t){const e=document.getElementsByTagName('meta');for(let n=0;n<e.length;n++)if(e[n].getAttribute('name')===t)return e[n];return''}if(window.localStorage&&localStorage.getItem('theme')){let e=localStorage.getItem('theme');e==='light'||e==='dark'||e==='black'?setTheme(e):window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light')}else''==='light'||''==='dark'||''==='black'?(setTheme(''),saveTheme('')):(saveTheme('auto'),window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light'));let metaColors={light:'#f8f8f8',dark:'#252627',black:'#000000'};getMeta('theme-color').content=metaColors[document.body.getAttribute('theme')]</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="All about IoT">All about IoT</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=https://www.humminglab.io/ rel="noopener noreffer" target=_blank>HummingLab </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="All about IoT">All about IoT</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=https://www.humminglab.io/ title rel="noopener noreffer" target=_blank>HummingLab</a><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class="toc-content always-active" id=toc-content-auto></div></div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">TLS/암호 알고리즘 쉽게 이해하기(10) - Hash</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.humminglab.io/authors/yslee>YSLee</a></span>
</span>&nbsp;<span class=post-category>included in </span>&nbsp;<span class=post-category>category <a href=/categories/security/><i class="far fa-folder fa-fw"></i>Security</a></span>&nbsp;<span class=post-category>and</span>&nbsp;<span class=post-series>series <a href=/series/tls/%EC%95%94%ED%98%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/><i class="far fa-list-alt fa-fw"></i>TLS/암호 알고리즘 쉽게 이해하기</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-04-16>2022-04-16</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2022-06-16>2022-06-16</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1427 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;7 minutes&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#암호화-hash의-특징>암호화 hash의 특징</a></li><li><a href=#hash-함수의-구성>Hash 함수의 구성</a></li><li><a href=#hash-함수들>Hash 함수들</a></li><li><a href=#md5-sha-1-취약점>MD5, SHA-1 취약점</a></li><li><a href=#sha-3>SHA-3</a></li><li><a href=#마치며>마치며</a></li></ul></nav></div></div><div class=content id=content><p>Hash 함수란 임의의 길이의 데이타를 축약하여 고정된 길이의 데이타로 매핑하는 함수를 말한다.</p><p>데이타 검색을 위한 hash 함수, 데이타 손상을 검출하기 위한 CRC32 도 hash 함수 이지만, 이 글에서 언급하는 것은 암호화 해시 함수이다.</p><p>각 용도에 따라서 해시 함수의 특성은 다음처럼 다를 수 있다.</p><ul><li>데이터 검색용: 모든 입력 데이타에 대해서 hash 결과값이 균등 분포를 가져야 한다.</li><li>데이타 손상 검출용: 원하는 비트 개수 까지의 오류에 대해서 정확히 검출되어야 하고, 알고리즘에 따라서 제한된 비트 개수 까지 오류 복원이 가능하여야 한다.</li><li>암호화용: 해시 값으로 원본을 추측 불가능하여야 하고, 임의의 두 데이타가 동일한 해시값을 가지는 충돌이 실제적으로 불가능하여야 한다.</li></ul><h2 id=암호화-hash의-특징>암호화 hash의 특징</h2><p>우선 용어를 정리해 보자.</p><ul><li>역상(pre-image): hash 전의 데이타 원본</li><li>저항성(resistance): 내성</li><li>충돌(collision): 임의의 데이타의 hash 결과값이 동일한 값을 가지는 것</li></ul><p>암호화 hash 함수는 다음 조건을 만족하여야 한다.</p><ul><li>제 1 역상 저항성(first pre-image resistance): 해시 값으로 원본 메시지를 찾는 것이 현실적으로 불가능</li><li>제 2 역상 저항성(second pre-image resistance): 동일한 해시 값을 가진 2개의 데이타를 찾는 것(충돌)이 현실적으로 불가능</li></ul><p>제1역상 저항성을 만족하기 위하여는 원본 데이타의 1bit가 변경되면 결과값이 무작위한 난수처럼 변경되어야 한다.
이를 만족하고, hash 함수가 128bit의 결과값을 가진다면, $2^{128}$ 번 이상의 시도를 하여야 충돌을 찾을 수 있다.</p><p>하지만, 제 2 역상 저항성, 즉, 임의의 2개 메시지가 동일한 값을 가지는 것은 위의 것보다는 더 쉽게 찾을 수 있다.</p><p>이를 <a href=https://www.geeksforgeeks.org/birthday-paradox/ target=_blank rel="noopener noreffer">Birthday Paradox</a> 라고 하는데, 간단하게 설명하면 다음과 같다.</p><ul><li>나와 같은 생일을 가진 사람을 찾으려면 확률적으로 몇 명을 찾아보아야 할까?<ul><li>365명 이상</li></ul></li></ul><p>위의 질문은 쉽게 이해가 갈것이다.</p><p>그런데, 다음 질문의 답은 얼마가 될까?</p><ul><li>같은 생일을 가진 사람이 있을 확률이 50% 이상이려면 얼마의 사람을 모아야 할까?</li></ul><p>답은 23명이다. 즉, 한 방안에 23명이 모여 있다면 확률적으로 같은 생일을 가진 사람이 있을 확률이 1/2 이상이라는 말이다.</p><p>이것이 제 2 역상 저항성 충돌 문제로, 하나의 원본과 동일한 해시 값을 가진 다른 메시지를 만들어 내는 것은 어렵지만,
동일한 해시 값을 가진 두 메시지를 만들어 내는 것은 상대적으로 쉽다는 것이다.</p><p>수학적으로 보면 총 경우의 수를 N, 선정한 임의의 개수를 r이라고 하면 충돌이 발생할 가능성은 다음과 같다.</p><p>$$
\Pr \approx 1 - e^{\frac{-r^2}{2N}}
$$</p><p>간단히 말하면 $n$ bit의 결과값을 hash 함수에 대해서 단순하게 찾는다면 제1역상은 $2^n$ 회의 연산이 필요하지만, 제2역상은 $2^{n/2}$ 회의 연산이면 된다.</p><p>좀더 직관적으로 보기 위해 32bit의 hash 함수를 보면 단순 무식 충돌 찾기의 횟수는 다음과 같다.</p><ul><li>제1역상 찾기: $2^{32} = 4,294,967,296$</li><li>제2역상 찾기: $2^{32/2} = 65,536$</li></ul><p>제1역상은 42억번의 시도를 해보아야 하지만 제2역상은 6만번이면 찾을 수 있다.</p><p>다만 이렇게 찾으려면 65,536개의 결과값을 저장하고 비교해야 하는데, 비트수가 커지면 결과를 저장할 공간이 무한히 커져야 하는 문제가 있다.
물론 메모리를 적게 사용하는 위한 <a href=https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm target=_blank rel="noopener noreffer">Pollard&rsquo;s rho algorithm</a>와 같은 공격 방법들이 있다.</p><h2 id=hash-함수의-구성>Hash 함수의 구성</h2><p>현재 사용하는 MD5, SHA-1, SHA-2 방식은 전체 메시지를 압축하여 하나의 결과값을 만드는 구조가 아니라, AES 블럭 암호화 처럼 블럭단위로 압축을 하고, 이를 연쇄적으로 이어가는 방식이다.</p><p>Hash에서 이 구조를 <a href=https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction target=_blank rel="noopener noreffer">Merkle–Damgård construction</a> 라고 하고, 위키피디아에 있는 아래 그림과 같은 구조이다.</p><figure><img src=2880px-Merkle-Damgard_hash_big.svg.png alt="PKCS#1 v1.5 padding" width=600px height=auto><figcaption><p>PKCS#1 v1.5 padding</p></figcaption></figure><p>이전 글의 <a href=https://blog.humminglab.io/posts/tls-cryptography-4-block-cipher-mode/ rel>Block Cipher Mode</a>의 AES-CBC 모드처럼 구성된 것이라고 보면 된다.</p><p>실제로 <a href=https://en.wikipedia.org/wiki/One-way_compression_function#Davies%E2%80%93Meyer target=_blank rel="noopener noreffer">Davies-Meyer</a> 방식의 경우 암호함수를 이용하여 hash를 구성하기도 한다.</p><p>이와 같은 체인 구조의 경우 안전한 함수를 사용한 경우 어떠 크기의 데이타라도 압축하여 hash 값을 만들 수 있으나, 취약점이 발견된다면 데이타를 조작 가능한 문제점을 가지고 있다.</p><h2 id=hash-함수들>Hash 함수들</h2><p>가장 많이 사용하는 hash 함수는 MD5 와 SHA 계열이다.</p><p>MD5는 1992년 <a href=https://www.rfc-editor.org/rfc/rfc1321.html target=_blank rel="noopener noreffer">RFC 1321</a>로 정의된 것이고, SHA(Secure Hash Algorithm)는 미국 NIST에서 제정한 표준이다.
SHA는 버전에 따라서, SHA-1, SHA-2, SHA-3 로 구분이 된다. SHA-2, SHA-3는 몇가지의 hash 값 길이를 제공한다.</p><p>보통 특정한 언급없이 SHA-256, SHA-384, SHA-512 와 같이 비트길이를 적은 것은 SHA-2 말하는 것이다. SHA-3 의 경우 SHA3-256 과 같이 표기한다.</p><p>각 함수들의 특징을 비교하면 다음과 같다.</p><table><thead><tr><th>Algorithm</th><th>Name</th><th>Output Size(bit)</th><th>Internal Size(bit)</th><th>Block Size(bit)</th><th>길이 한계</th></tr></thead><tbody><tr><td>MD5</td><td>MD5</td><td>128</td><td>128</td><td>512</td><td>$2^{64}-1$</td></tr><tr><td>SHA-1</td><td>SHA-1</td><td>160</td><td>160</td><td>512</td><td>$2^{64}-1$</td></tr><tr><td>SHA-2</td><td>SHA-224</td><td>224</td><td>256</td><td>512</td><td>$2^{64}-1$</td></tr><tr><td></td><td>SHA-256</td><td>256</td><td>256</td><td>512</td><td>$2^{64}-1$</td></tr><tr><td></td><td>SHA-384</td><td>384</td><td>512</td><td>1024</td><td>$2^{128}-1$</td></tr><tr><td></td><td>SHA-512</td><td>512</td><td>512</td><td>1024</td><td>$2^{128}-1$</td></tr><tr><td>SHA-3</td><td>SHA3-224</td><td>224</td><td>1600</td><td>1152</td><td></td></tr><tr><td></td><td>SHA3-256</td><td>256</td><td>1600</td><td>1088</td><td></td></tr><tr><td></td><td>SHA3-384</td><td>384</td><td>1600</td><td>832</td><td></td></tr><tr><td></td><td>SHA3-512</td><td>512</td><td>1600</td><td>576</td><td></td></tr></tbody></table><p>현시점에서 MD5, SHA-1은 충돌이 발견되어 더 이상 암호 용도로는 사용을 제한하고, TLS 1.2 부터는 제외되었다.</p><ul><li><a href=https://tools.ietf.org/id/draft-lvelvindron-tls-md5-sha1-deprecate-01.html target=_blank rel="noopener noreffer">Deprecating MD5 and SHA1 in TLS 1.2</a></li><li><a href=https://datatracker.ietf.org/doc/html/rfc5246#section-1.2 target=_blank rel="noopener noreffer">RFC 5246 - TLS 1.2, Major Difference from TLS 1.1</a></li></ul><p>MD5, SHA-1, SHA-2 의 경우 기본 구성은 동일한 <a href=https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction target=_blank rel="noopener noreffer">Merkle–Damgård construction</a> 구조로, SHA-2 도 언젠가는 유사한 취약점이 발견될 수도 있다. 물론 현재까지는 SHA-2는 안전한 암호화 hash 함수이다.</p><p>SHA-1, SHA-2의 입력 데이타의 길이 제한이 있는 이유는 입력 데이타를 블럭 크기로 맞추면서 패딩 시 데이타 크기를 기록하기 때문에 이 부분으로 인하여 제한이다.</p><h2 id=md5-sha-1-취약점>MD5, SHA-1 취약점</h2><p>아래 링크를 보면 이와 같은 MD5 의 취약점을 이용하여 동일한 hash 값을 가지지만 다른 동작을 하는 프로그램을 직접 만들어 볼 수도 있다.</p><ul><li><a href=https://www.mscs.dal.ca/~selinger/md5collision/ target=_blank rel="noopener noreffer">Peter Selinger: MD5 Collision Demo</a></li></ul><p><a href=https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction target=_blank rel="noopener noreffer">Merkle–Damgård construction</a> 구조에서 각 블럭은 initial vertor(또는 이전 블럭의 결과값) 과 데이타 블럭이 압축 함수를 거치는 구조이다.</p><p>그런데 특정 블럭 $M, M&rsquo;, N, N&rsquo;$ 이 있는 경우 어떠한 initial vector $s$ 에 대해서도 다음과 같은 조건을 만족하는 경우가 발견되었다.</p><p>$$ f(f(s, M), M&rsquo;) = f(f(s, N), N&rsquo;) $$</p><p>이 의미는 데이타 블럭에 $M, M&rsquo;$ 이 있는 경우 이를 $N, N&rsquo;$ 으로 대치 하여도 동일한 해시값을 가진 경우가 생긴다.
이와 같은 방식으로 중간의 특정 블럭을 교체하여, 동일한 hash 값을 가지도록 하고, 이 블럭을 참조하여 다른 동작을 하는 프로그램을 만든다.</p><p>실행 파일도 그렇지만 인증서와 같은 문서도 이처럼 충돌되도록 만드는 것도 가능하다고 한다.</p><p>SHA-1 의 경우에도 마찬가지로 충돌 방법이 발견되었고 아래 링크에서 확인해 볼 수 있다.</p><ul><li><a href=https://shattered.io/ target=_blank rel="noopener noreffer">SHAttered</a></li></ul><h2 id=sha-3>SHA-3</h2><p>MD5에서 나온 충돌 문제처럼, 임의의 문서에서 문서의 내용을 악의적으로 바꿀 수 있는 비트를 몇십개를 선정해서 이를 알고리즘의 취약점이나 brithday attack 과 같은 방법으로 찾아 나가면
유사한 체인 구조를 가진 SHA-2 도 취약점이 발견될 가능성이 있다.</p><p>이런 염려로 NIST에서는 2007년에 기존의 SHA-1, SHA-2 와는 구조와는 완전히 다른 해시 함수를 공모를 시작하여 최종적으로 2015년에 <a href=https://keccak.team/keccak.html target=_blank rel="noopener noreffer">Keccak</a> 해시 함수를 SHA-3 로 선정하여 2015년에 발표하였다.</p><p>이 방식의 특징은 위의 표에서 보듯이 내부 1600비트의 상태를 치환해서 SHA-2 와 동일한 결과 비트를 만들어 낸다. 십년 이상의 연구 결과로 나온 것으로 악용 가능한 취약점이 전혀 없는 강한 알고리즘이다.</p><p>하지만 아래와 같이 속도를 측정해보면 동일한 출력 비트에 비해서 SHA-1, SHA-2 에 비하여 상대적으로 느리다는 단점이 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl speed -evp sha1
</span></span><span class=line><span class=cl>Doing sha1 <span class=k>for</span> 3s on <span class=m>16</span> size blocks: <span class=m>12130080</span> sha1<span class=s1>&#39;s in 3.00s
</span></span></span><span class=line><span class=cl><span class=s1>Doing sha1 for 3s on 64 size blocks: 9737560 sha1&#39;</span>s in 2.99s
</span></span><span class=line><span class=cl>Doing sha1 <span class=k>for</span> 3s on <span class=m>256</span> size blocks: <span class=m>6238334</span> sha1<span class=s1>&#39;s in 3.00s
</span></span></span><span class=line><span class=cl><span class=s1>Doing sha1 for 3s on 1024 size blocks: 2627777 sha1&#39;</span>s in 2.99s
</span></span><span class=line><span class=cl>Doing sha1 <span class=k>for</span> 3s on <span class=m>8192</span> size blocks: <span class=m>407163</span> sha1<span class=s1>&#39;s in 2.99s
</span></span></span><span class=line><span class=cl><span class=s1>Doing sha1 for 3s on 16384 size blocks: 207609 sha1&#39;</span>s in 3.00s
</span></span><span class=line><span class=cl>OpenSSL 1.1.1m  <span class=m>14</span> Dec <span class=m>2021</span>
</span></span><span class=line><span class=cl>built on: Tue Dec <span class=m>14</span> 15:45:01 <span class=m>2021</span> UTC
</span></span><span class=line><span class=cl>options:bn<span class=o>(</span>64,64<span class=o>)</span> rc4<span class=o>(</span>16x,int<span class=o>)</span> des<span class=o>(</span>int<span class=o>)</span> aes<span class=o>(</span>partial<span class=o>)</span> idea<span class=o>(</span>int<span class=o>)</span> blowfish<span class=o>(</span>ptr<span class=o>)</span>
</span></span><span class=line><span class=cl>compiler: clang -fPIC -arch x86_64 -O3 -Wall -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DAESNI_ASM -DVPAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPOLY1305_ASM -D_REENTRANT -DNDEBUG
</span></span><span class=line><span class=cl>The <span class=s1>&#39;numbers&#39;</span> are in 1000s of bytes per second processed.
</span></span><span class=line><span class=cl><span class=nb>type</span>             <span class=m>16</span> bytes     <span class=m>64</span> bytes    <span class=m>256</span> bytes   <span class=m>1024</span> bytes   <span class=m>8192</span> bytes  <span class=m>16384</span> bytes
</span></span><span class=line><span class=cl>sha1             64693.76k   208429.38k   532337.83k   899947.71k  1115544.92k  1133821.95k
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ openssl speed -evp sha256
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl><span class=nb>type</span>             <span class=m>16</span> bytes     <span class=m>64</span> bytes    <span class=m>256</span> bytes   <span class=m>1024</span> bytes   <span class=m>8192</span> bytes  <span class=m>16384</span> bytes
</span></span><span class=line><span class=cl>sha256           50676.02k   141399.80k   316782.51k   462059.86k   532104.65k   531109.21k
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ openssl speed -evp sha3-256
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl><span class=nb>type</span>             <span class=m>16</span> bytes     <span class=m>64</span> bytes    <span class=m>256</span> bytes   <span class=m>1024</span> bytes   <span class=m>8192</span> bytes  <span class=m>16384</span> bytes
</span></span><span class=line><span class=cl>sha3-256         28803.58k   115073.18k   292266.75k   367422.16k   420298.92k   428512.60k
</span></span></code></pre></td></tr></table></div></div><p>결과를 정리해 보면 다음과 같다. 아래 결과는 해당 블럭을 암호화 했을 때 동일 시간에서 처리량이다.</p><table><thead><tr><th>type</th><th>16 bytes</th><th>64 bytes</th><th>256 bytes</th><th>1024 bytes</th><th>8192 bytes</th><th>16384 bytes</th></tr></thead><tbody><tr><td>sha1</td><td>64693.76k</td><td>208429.38k</td><td>532337.83k</td><td>899947.71k</td><td>1115544.92k</td><td>1133821.95k</td></tr><tr><td>sha256</td><td>50676.02k</td><td>141399.80k</td><td>316782.51k</td><td>462059.86k</td><td>532104.65k</td><td>531109.21k</td></tr><tr><td>sha3-256</td><td>28803.58k</td><td>115073.18k</td><td>292266.75k</td><td>367422.16k</td><td>420298.92k</td><td>428512.60k</td></tr></tbody></table><p>SHA-1은 160bit 라 256bit인 SHA-2, SHA-3와는 직접 비교는 되지 않지만, 어쨋든 SHA-1 이 빠르기도 하고 사용하던 관성에 있어 아직도 많이 사용하고 있다.</p><p>예를 들어 git 은 현재도 default로 SHA-1 hash 를 이용하여 commit 버전 관리를 하고 있고, 2020년 10월 v2.29 부터 expreimental 기능으로 SHA256을 지원하기 시작한다.</p><ul><li><a href=https://git-scm.com/docs/hash-function-transition/ target=_blank rel="noopener noreffer">Git - hash-function-transition Documentation</a></li><li><a href=https://en.wikipedia.org/wiki/Git#Releases target=_blank rel="noopener noreffer">Git Release</a></li></ul><p>SHA-3의 경우 SHA-2 와 비교하여 속도가 느리기도 하고, 아직까지는 SHA-2 취약점이 발견되지 않았기 때문에 한 동안은 SHA-2 가 더 많이 이용될 것으로 보인다.</p><p>Openssl에서는 openssl dgst 명령으로 hash 함수의 결과를 확인해 볼 수 있고 자주 사용하다 보니 별도의 명령으로도 나와 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl dgst -sha256 mydata.txt
</span></span><span class=line><span class=cl>SHA256<span class=o>(</span>mydata.txt<span class=o>)=</span> 4795a1c2517089e4df569afd77c04e949139cf299c87f012b894fccf91df4594
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ openssl sha256 mydata.txt
</span></span><span class=line><span class=cl>SHA256<span class=o>(</span>mydata.txt<span class=o>)=</span> 4795a1c2517089e4df569afd77c04e949139cf299c87f012b894fccf91df4594
</span></span></code></pre></td></tr></table></div></div><h2 id=마치며>마치며</h2><p>보안이 강조되는 프로그램에서 hash를 사용하여야 한다면 현재로서는 SHA-256 이 가장 적절한 솔루션일 것이다.</p><p>혹시나 SHA-2 방식의 구조가 염려되나 SHA-3 느린 성능이 불만이라면, <a href=https://www.blake2.net target=_blank rel="noopener noreffer">Blake2</a> hash 함수와 같은 것도 검토해 볼 수 있다.</p><p>암호화 라이브러리에 지원되는 hash 함수들은 아래 링크에서 찾아볼 수 있다.</p><ul><li><a href=https://en.wikipedia.org/wiki/Comparison_of_cryptography_libraries#Hash_functions target=_blank rel="noopener noreffer">Comparison of cryptography libraries - Wikipedia</a></li></ul><p>다른 암호도 마찬가지이지만, 특별한 이유가 없다면 직접 구현하는 것 보다는 이와 같은 공개적으로 검증된 알고리즘과 암호화 라이브러리를 사용하는 것이 좋을 것이다. 직접 구현을 하다보면 사소한 실수로 암호 강도가 크게 떨어지는 문제가 발생할 수 있다.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-06-16</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/cryptography-md5-sha-blake2/>Cryptography, MD5, SHA, BLAKE2</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/tls-cryptography-9-dsa/ class=prev rel=prev title="TLS/암호 알고리즘 쉽게 이해하기(9) - Digital Signature"><i class="fas fa-angle-left fa-fw"></i>TLS/암호 알고리즘 쉽게 이해하기(9) - Digital Signature</a>
<a href=/posts/tls-cryptography-11-ecc/ class=next rel=next title="TLS/암호 알고리즘 쉽게 이해하기(11) - Elliptic Curve Cryptography(ECC)">TLS/암호 알고리즘 쉽게 이해하기(11) - Elliptic Curve Cryptography(ECC)<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=giscus></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/>giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://www.humminglab.io target=_blank rel="noopener noreferrer">HummingLab</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-83257319-3',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-83257319-3" async></script></div><div class=pjax-assets><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{giscus:{darkTheme:"dark",dataCategory:"Announcements",dataCategoryId:"DIC_kwDOGdk00s4CAGXN",dataEmitMetadata:"0",dataMapping:"pathname",dataReactionsEnabled:"1",dataRepo:"humminglab/blog.humminglab.io",dataRepoId:"R_kgDOGdk00g",lightTheme:"light"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/katex/katex.min.css><noscript><link rel=stylesheet href=/lib/katex/katex.min.css></noscript><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript></div></body></html>