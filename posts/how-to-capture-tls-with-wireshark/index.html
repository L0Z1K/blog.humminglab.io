<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<title class=pjax-title>Wireshark 으로 TLS 캡쳐 및 디코딩 하기 - All about IoT</title><meta name=Description content><meta property="og:title" content="Wireshark 으로 TLS 캡쳐 및 디코딩 하기">
<meta property="og:description" content="프로토콜을 개발하거나 검증하려고 할 때 SSL/TLS 암호화 채널로 전송되는 데이타를 디코딩하여 확인이 필요할 때가 있다. 이 글에서는 시험하려는 프로그램의 수정 없이 또는 최소한의 수정으로 디코딩 하는 방법을 설명한다.
개요 TLS 채널의 초기 셋업 절차는 크게 보면 다음과 같은 절차로 이루어진다.
 서버 인증서를 받아서 검증하기 필요하면 클라이언트 인증서를 받아서 검증하기 암호화 방식을 이용하여 대칭키 교환 대칭키를 이용한 암호화된 데이타 송수신  패킷을 분석하기에 필요한 사항은 결국은 위 세번째 과정에서 교환한 대칭키(Master Secret)를 얻는 것이다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.humminglab.io/posts/how-to-capture-tls-with-wireshark/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-12-21T16:00:00+09:00">
<meta property="article:modified_time" content="2021-12-22T10:00:00+09:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Wireshark 으로 TLS 캡쳐 및 디코딩 하기">
<meta name=twitter:description content="프로토콜을 개발하거나 검증하려고 할 때 SSL/TLS 암호화 채널로 전송되는 데이타를 디코딩하여 확인이 필요할 때가 있다. 이 글에서는 시험하려는 프로그램의 수정 없이 또는 최소한의 수정으로 디코딩 하는 방법을 설명한다.
개요 TLS 채널의 초기 셋업 절차는 크게 보면 다음과 같은 절차로 이루어진다.
 서버 인증서를 받아서 검증하기 필요하면 클라이언트 인증서를 받아서 검증하기 암호화 방식을 이용하여 대칭키 교환 대칭키를 이용한 암호화된 데이타 송수신  패킷을 분석하기에 필요한 사항은 결국은 위 세번째 과정에서 교환한 대칭키(Master Secret)를 얻는 것이다.">
<meta name=application-name content="All about IoT">
<meta name=apple-mobile-web-app-title content="All about IoT">
<meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://blog.humminglab.io/posts/how-to-capture-tls-with-wireshark/><link rel=prev href=https://blog.humminglab.io/posts/how-to-oci-wireguard-public-ipv6/><link rel=next href=https://blog.humminglab.io/posts/yocto-project-on-orage-pi-1/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/fontawesome-free/all.min.css>
<noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/animate/animate.min.css>
<noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Wireshark 으로 TLS 캡쳐 및 디코딩 하기","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.humminglab.io\/posts\/how-to-capture-tls-with-wireshark\/"},"genre":"posts","keywords":"Wireshark, TLS, MbedTLS, OpenSSL, WebProxy","wordcount":771,"url":"https:\/\/blog.humminglab.io\/posts\/how-to-capture-tls-with-wireshark\/","datePublished":"2021-12-21T16:00:00+09:00","dateModified":"2021-12-22T10:00:00+09:00","publisher":{"@type":"Organization","name":"HummingLab"},"authors":[{"@type":"Person","name":"YSLee"}],"description":""}</script></head>
<body header-desktop header-mobile><script type=text/javascript>function setTheme(a){document.body.setAttribute('theme',a)}function saveTheme(a){window.localStorage&&localStorage.setItem('theme',a)}function getMeta(b){const a=document.getElementsByTagName('meta');for(let c=0;c<a.length;c++)if(a[c].getAttribute('name')===b)return a[c];return''}if(window.localStorage&&localStorage.getItem('theme')){let a=localStorage.getItem('theme');a==='light'||a==='dark'||a==='black'?setTheme(a):window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light')}else''==='light'||''==='dark'||''==='black'?(setTheme(''),saveTheme('')):(saveTheme('auto'),window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light'));let metaColors={light:'#f8f8f8',dark:'#252627',black:'#000000'};getMeta('theme-color').content=metaColors[document.body.getAttribute('theme')]</script>
<div id=back-to-top></div>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="All about IoT">All about IoT</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> Posts </a><a class=menu-item href=/tags/> Tags </a><a class=menu-item href=/categories/> Categories </a><a class=menu-item href=https://www.humminglab.io/ rel="noopener noreffer" target=_blank> HummingLab </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="All about IoT">All about IoT</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=https://www.humminglab.io/ title rel="noopener noreffer" target=_blank>HummingLab</a><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>Contents</h2>
<div class="toc-content always-active" id=toc-content-auto></div>
</div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Wireshark 으로 TLS 캡쳐 및 디코딩 하기</h1><div class=post-meta>
<div class=post-meta-line>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.humminglab.io/authors/yslee>YSLee</a></span>
</span>&nbsp;<span class=post-category>included in </span>&nbsp;<span class=post-category>category <a href=/categories/security/><i class="far fa-folder fa-fw"></i>Security</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-12-21>2021-12-21</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2021-12-22>2021-12-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;771 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;4 minutes&nbsp;</div>
</div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#개요>개요</a></li>
<li><a href=#rsa-private-key를-이용한-패킷-디코딩>RSA Private key를 이용한 패킷 디코딩</a></li>
<li><a href=#master-secret-을-얻어서-디코딩-하기>Master Secret 을 얻어서 디코딩 하기</a>
<ul>
<li><a href=#웹-브라우저>웹 브라우저</a></li>
<li><a href=#nodejs>Node.js</a></li>
<li><a href=#mbedtls-library>MbedTLS library</a></li>
<li><a href=#openssl-library>OpenSSL library</a></li>
</ul>
</li>
<li><a href=#마무리>마무리</a></li>
</ul>
</nav></div>
</div><div class=content id=content><p>프로토콜을 개발하거나 검증하려고 할 때 SSL/TLS 암호화 채널로 전송되는 데이타를 디코딩하여 확인이 필요할 때가 있다.
이 글에서는 시험하려는 프로그램의 수정 없이 또는 최소한의 수정으로 디코딩 하는 방법을 설명한다.</p>
<h2 id=개요>개요</h2>
<p>TLS 채널의 초기 셋업 절차는 크게 보면 다음과 같은 절차로 이루어진다.</p>
<ul>
<li>서버 인증서를 받아서 검증하기</li>
<li>필요하면 클라이언트 인증서를 받아서 검증하기</li>
<li>암호화 방식을 이용하여 대칭키 교환</li>
<li>대칭키를 이용한 암호화된 데이타 송수신</li>
</ul>
<p>패킷을 분석하기에 필요한 사항은 결국은 위 세번째 과정에서 교환한 대칭키(Master Secret)를 얻는 것이다. 다음은 이를 얻을 수 있는 방법 들을 정리한다.</p>
<h2 id=rsa-private-key를-이용한-패킷-디코딩>RSA Private key를 이용한 패킷 디코딩</h2>
<p>대칭키를 교환하는 방법은 크게 다음과 같은 두가지 방식을 사용한다.</p>
<ul>
<li>RSA와 같은 비대칭키를 이용하여 대칭키 교환</li>
<li>DHKE(Diffie-Hellman Key Exchange) 방식의 키 교환</li>
</ul>
<p>이들 중 다음과 같은 조건을 만족하는 경우 서버의 RSA private key를 이용하여 디코딩이 가능하다.</p>
<ul>
<li>DH 방식의 키교환은 불가능</li>
<li>TLS 1.2 이하 인 경우 가능. TLS 1.3은 불가능</li>
<li>서버 인증서로만 가능</li>
<li>TLS handshake message 중 <code>ClientKeyExchange</code> 패킷이 캡쳐 된 경우</li>
</ul>
<p>간단히 말해서 TLS1.2 이하이어야 하고, RSA를 이용한 키교환만 가능하다는 것이다.</p>
<p>예를들어, AWS IoT 서버와 통신을 하는 경우를 디코딩 하려면, 우선 지원되는 TLS cipher suites 목록을 아래에서 확인할 수 있다.</p>
<ul>
<li><a href=https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html target=_blank rel="noopener noreffer">Transport security in AWS IoT</a></li>
</ul>
<p>이들 목록 중 앞부분의 &lsquo;ECDHE-&rsquo; 로 시작하는 것을 제외한 AES128-GCM-SHA256, AES128-SHA256, AES128-SHA, AES256-GCM-SHA384, AES256-SHA256 만 사용하도록 제한하여야 한다.</p>
<p>Wireshark의 설정 -> RSA Keys 에 RSA private key를 등록하면 된다. 관련된 설명은 <a href=https://wiki.wireshark.org/TLS target=_blank rel="noopener noreffer">Wireshark - Transport Layer Security (TLS)</a>에 자세히 설명되어 있다.</p>
<p>하지만 이 방식은 서버인증서의 개인키를 가지고 있어야 하는데, 임시 시험용 서버가 아닌 이상 서버의 private key를 얻을 수 있는 방법은 없으므로 실제적으로 활용 가능한 경우는 많이 없다.</p>
<h2 id=master-secret-을-얻어서-디코딩-하기>Master Secret 을 얻어서 디코딩 하기</h2>
<h3 id=웹-브라우저>웹 브라우저</h3>
<p>Firefox browser 의 경우 NSS (Network Security Services) 모듈에서 TLS 관련 기능을 처리한다.
참고로 <a href=https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_API_Guidelines target=_blank rel="noopener noreffer">NSS layer</a>는 아래와 같은 레이어링을 제공한다.</p>
<figure><a class=lightgallery href=https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_API_Guidelines/layer.gif title=https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_API_Guidelines/layer.gif data-thumbnail=https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_API_Guidelines/layer.gif data-sub-html="<h2>NSS Layer</h2>">
<img class=lazyload data-src=https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_API_Guidelines/layer.gif data-srcset="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_API_Guidelines/layer.gif, https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_API_Guidelines/layer.gif 1.5x, https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_API_Guidelines/layer.gif 2x" data-sizes=auto alt=https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_API_Guidelines/layer.gif height=auto width=300px>
</a><figcaption class=image-caption>NSS Layer</figcaption>
</figure>
<p>이 NSS 에서 디버깅을 위한 <a href=https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format target=_blank rel="noopener noreffer">NSS Key Log</a> 기능을 제공한다.
이 기능을 켜기 위하여는 환경 변수에 <code>SSLKEYLOGFILE</code> 로 로그를 저장할 파일을 지정해 주면 된다. Firefox 이외에도 Chrome 브라우저도 동일한 기능을 제공한다.</p>
<p>아래 예는 mac 의 경우이고, linux 나 windows 도 동일한 방법으로 환경 변수를 설정해서 사용하면 된다. (<a href=https://support.f5.com/csp/article/K50557518 target=_blank rel="noopener noreffer">설정관련 참고</a>)</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>$ <span class=nv>SSLKEYLOGFILE</span><span class=o>=</span>/tmp/tlskey.log open -n /Applications/Firefox.app
$ <span class=nv>SSLKEYLOGFILE</span><span class=o>=</span>/tmp/tlskey.log open -n /Applications/Google<span class=se>\ </span>Chrome.app
</code></pre></td></tr></table>
</div>
</div><p>위와 같이 환경 변수를 설정하여 브라우저를 실행하면 웹 페이지를 열 때마다 로그파일에 로그가 추가된다. 이 중 대칭키 디코딩에 필요한 라인은 <code>CLIENT_RANDOM</code> 으로 아래와 같이 랜덤 값과, master secret 으로 구성된다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>CLIENT_RANDOM 5ab65015dc125e2aa00daececfa52ff37489daf6a20375cf140d5f14e291e2ec 64df1871ca4a4be463872aef5f29caff98cfeff4b2a0f0193951947533212dc30766f03b4d202de43f93a265a828e393
</code></pre></td></tr></table>
</div>
</div><p>Wireshark의 설정 -> Protocols -> TLS 의 &lsquo;(Pre)-Master-Secret log fiename&rsquo; 에 해당 파일을 설정하면 자동으로 TLS 데이타가 디코딩 된다.</p>
<figure><a class=lightgallery href=/posts/how-to-capture-tls-with-wireshark/wireshark-tls.png title=/posts/how-to-capture-tls-with-wireshark/wireshark-tls.png data-thumbnail=/posts/how-to-capture-tls-with-wireshark/wireshark-tls.png data-sub-html="<h2>Master-Secret 설정</h2>">
<img class=lazyload data-src=wireshark-tls.png data-srcset="/posts/how-to-capture-tls-with-wireshark/wireshark-tls.png, wireshark-tls.png 1.5x, /posts/how-to-capture-tls-with-wireshark/wireshark-tls.png 2x" data-sizes=auto alt=/posts/how-to-capture-tls-with-wireshark/wireshark-tls.png height=auto width=600px>
</a><figcaption class=image-caption>Master-Secret 설정</figcaption>
</figure>
<h3 id=nodejs>Node.js</h3>
<p>개발하는 프로그램이 node.js 로 작성한다면 위의 웹 브라우저와 동일한 기능을 수행하는 <a href=https://www.npmjs.com/package/sslkeylog target=_blank rel="noopener noreffer">node-sslkeylog</a> 패키지를 사용할 수 있다.</p>
<p>코드 상에 아래처럼 추가를 하면 SSLKEYLOGFILE 환경 변수로 컨트롤이 가능하다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=nx>require</span><span class=p>(</span><span class=s2>&#34;sslkeylog&#34;</span><span class=p>).</span><span class=nx>hookAll</span><span class=p>();</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=mbedtls-library>MbedTLS library</h3>
<p>사용하는 기기가 RTOS 기반 IoT 모듈 이라면 TLS 관련 library를 수정하여야 한다. 모듈이 mbedTLS 를 사용한다면 아래 링크과 같이 patch를 적용한다.</p>
<ul>
<li><a href=https://github.com/Lekensteyn/mbedtls/commit/68aea15 target=_blank rel="noopener noreffer">Example code to produce key log file compatible with Wireshark</a></li>
</ul>
<p>위 patch 는 위와 유사한 방식으로 fputs 를 이용하여 <code>CLIENT_RANDOM</code> 을 출력 시킨다.</p>
<p>이와 같은 시나리오로 WiFI IoT 모듈의 TLS 패킷 캡쳐는 다음과 같이 할 수 있다.</p>
<figure><a class=lightgallery href=/posts/how-to-capture-tls-with-wireshark/iot-capture.png title=/posts/how-to-capture-tls-with-wireshark/iot-capture.png data-thumbnail=/posts/how-to-capture-tls-with-wireshark/iot-capture.png data-sub-html="<h2>IoT 캡쳐</h2>">
<img class=lazyload data-src=iot-capture.png data-srcset="/posts/how-to-capture-tls-with-wireshark/iot-capture.png, iot-capture.png 1.5x, /posts/how-to-capture-tls-with-wireshark/iot-capture.png 2x" data-sizes=auto alt=/posts/how-to-capture-tls-with-wireshark/iot-capture.png height=auto width=400px>
</a><figcaption class=image-caption>IoT 캡쳐</figcaption>
</figure>
<ul>
<li>IoT 모듈의 디버깅 로그를 UART로 PC와 연결하여 디버깅 로그 출력</li>
<li>로그를 <a href=https://linux.die.net/man/8/picocom target=_blank rel="noopener noreffer">picocom</a>와 같이 terminal 프로그램 이용하여 CLIENT_RANDOM만 추출</li>
<li>아래와 같이 두개의 스크립트를 각각 실행</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>$ picocom -b <span class=m>115200</span> /dev/ttyUSB0 <span class=p>|</span> tee /tmp/test.log
$ tail -f /tmp/test.log <span class=p>|</span> grep --line-buffered CLIENT_RANDOM <span class=p>|</span> sed -l -e <span class=s2>&#34;s/\r//g&#34;</span> &gt;&gt; /tmp/tlskey.log
</code></pre></td></tr></table>
</div>
</div><p>첫번째 줄은 로그 출력 결과를 test.log에 임시로 저장. 두번째 줄은 이 로그 중 <code>CLIENT_RANDOM</code> 이 들어간 문장만 tlskey.log로 추가 하는 것이다.</p>
<p>위와 같이 한 상태에서 IoT 모듈의 패킷을 캡쳐하면 디코딩이 가능하다.</p>
<h3 id=openssl-library>OpenSSL library</h3>
<p>OpenSSL 도 비슷한 방식으로 캡쳐가 가능하다. OpenSSL 버전에 따라 대응 방법이 다르다.</p>
<ul>
<li>
<p>OpenSSL v1.1.1 이상인 경우</p>
<ul>
<li><a href=https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_keylog_callback.html target=_blank rel="noopener noreffer">SSL_CTX_set_keylog_callback()</a> 함수로 출력 가능</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=n>SSL_CTX_set_keylog_callback</span><span class=p>(</span><span class=n>mosq</span><span class=o>-&gt;</span><span class=n>ssl_ctx</span><span class=p>,</span> <span class=n>SSL_CTX_keylog_cb_func_cb</span><span class=p>);</span>
</code></pre></td></tr></table>
</div>
</div><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=kt>void</span> <span class=nf>SSL_CTX_keylog_cb_func_cb</span><span class=p>(</span><span class=k>const</span> <span class=n>SSL</span> <span class=o>*</span><span class=n>ssl</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>line</span><span class=p>){</span>
  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>line</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>이전 버전인 경우 ssl/ssl_lib.c 의 SSL_read() 에서 <code>(SSL *)s->session->master_key</code> 를 적절하게 출력시키기</p>
</li>
</ul>
<p>IoT 기기의 경우 가벼운 mbedTLS 를 주로 사용하여 OpenSSL을 이용한 시험은 실제로 해보지는 못하였다.</p>
<p>관련하여 실제 사용예는 아래 링크를 참고할 수 있다.</p>
<ul>
<li><a href=https://embeddedinn.xyz/articles/tutorial/hijacking-openssl-renegotiated-keys-for-server-wiretaps/ target=_blank rel="noopener noreffer">Hijacking openssl renegotiated keys for server wiretaps</a></li>
</ul>
<h2 id=마무리>마무리</h2>
<p>지금까지 Master Secret을 얻어서 패킷을 디코딩 하는 방법을 정리하였다.</p>
<p>물론 이와 같이 Master Secret을 구해서 디코딩 하지 않고, Web Proxy tool을 이용하여 중간에서 패킷을 가로채서 확인하는 방법도 있고, 상황에 따라서는 이 방법이 더 편리할 수도 있다.
유명한 툴로는 <a href=https://portswigger.net/burp target=_blank rel="noopener noreffer">Burp Suite</a>가 있고, 검색을 해보면 <a href=https://mitmproxy.org target=_blank rel="noopener noreffer">mtimproxy</a>와 같은 오픈소스 툴들도 있다.
이들 툴은 HTTPS 프로토콜만을 대상으로 하고 있어 MQTT over TLS 와 같은 다른 프로그램은 분석이 불가능하다.</p>
<p>시험 타겟이 HTTP proxy 기능 지원 여부에 따라서 다음과 같이 모니터링이 가능하다.</p>
<ul>
<li>HTTP proxy 지원하는 경우: proxy 주소만 web proxy 툴이 설정된 곳으로 설정</li>
<li>HTTP proxy를 미지원하는 경우: DNS 또는 Gateway 주소를 web proxy 툴의 주소로 설정하고, transparent proxy 모드로 모니터링</li>
</ul>
<p>TLS 를 위와 같은 방법을 이용하여 분석 환경을 구성한다면 좀 더 쉽게 검증하면서 개발이 가능할 것이다.</p>
</div>
<div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>Updated on 2021-12-22</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md></div>
<div class=post-info-share>
<span></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/wireshark/>Wireshark</a>,&nbsp;<a href=/tags/tls/>TLS</a>,&nbsp;<a href=/tags/mbedtls/>MbedTLS</a>,&nbsp;<a href=/tags/openssl/>OpenSSL</a>,&nbsp;<a href=/tags/webproxy/>WebProxy</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span>
</section>
</div>
<div class=post-nav><a href=/posts/how-to-oci-wireguard-public-ipv6/ class=prev rel=prev title="OCI, WireGuard 로 무료 공인 IPv6 주소 사용하기"><i class="fas fa-angle-left fa-fw"></i>OCI, WireGuard 로 무료 공인 IPv6 주소 사용하기</a>
<a href=/posts/yocto-project-on-orage-pi-1/ class=next rel=next title="Yocto Project 개발하기(1) - Orange Pi 보드 빌드">Yocto Project 개발하기(1) - Orange Pi 보드 빌드<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id=comments><div id=giscus></div><noscript>
Please enable JavaScript to view the comments powered by <a href=https://giscus.app/>giscus</a>.
</noscript></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://www.humminglab.io target=_blank rel="noopener noreferrer">HummingLab</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
</div></footer></div>
<div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top">
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments">
<i class="fas fa-comment fa-fw"></i>
</a>
</div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-83257319-3',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-83257319-3" async></script></div>
<div class=pjax-assets><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{giscus:{darkTheme:"dark",dataCategory:"Announcements",dataCategoryId:"DIC_kwDOGdk00s4CAGXN",dataEmitMetadata:"0",dataMapping:"pathname",dataReactionsEnabled:"1",dataRepo:"humminglab/blog.humminglab.io",dataRepoId:"R_kgDOGdk00g",lightTheme:"light"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/katex/katex.min.css>
<noscript><link rel=stylesheet href=/lib/katex/katex.min.css></noscript><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/katex/copy-tex.min.css>
<noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript></div>
</body>
</html>