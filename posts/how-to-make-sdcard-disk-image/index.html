<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<title class=pjax-title>SD card 디스크 이미지 만들고 수정하는 방법 정리 - All about IoT</title><meta name=Description content><meta property="og:title" content="SD card 디스크 이미지 만들고 수정하는 방법 정리">
<meta property="og:description" content="Yocto Project나 Buildroot를 이용하여 embedded linux 시스템을 빌드하면 SD card나 MMC에 쓸수 있는 이미지까지 생성해 준다. 하지만 빌드되는 디스크 이미지 형태와 다르게 파티셔닝을 하려면 관련된 정보들을 알고 있어야 한다.
여기에서는 dd, truncate, fdisk, parted, mount, losetup 등의 utility를 이용하여 디스크 이미지를 생성, 수정, 관리하는 방법을 정리한다.
물리적인 저장 디스크 관리 Linux의 경우 저장 디스크는 block device로 /dev 디렉토리에 아래와 같은 디바이스 파일이 생성된다. 아래의 예는 sda SSD 디스크로 한 개의 파티션(sda1)이 있다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.humminglab.io/posts/how-to-make-sdcard-disk-image/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-10-25T18:00:00+09:00">
<meta property="article:modified_time" content="2017-10-25T18:00:00+09:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="SD card 디스크 이미지 만들고 수정하는 방법 정리">
<meta name=twitter:description content="Yocto Project나 Buildroot를 이용하여 embedded linux 시스템을 빌드하면 SD card나 MMC에 쓸수 있는 이미지까지 생성해 준다. 하지만 빌드되는 디스크 이미지 형태와 다르게 파티셔닝을 하려면 관련된 정보들을 알고 있어야 한다.
여기에서는 dd, truncate, fdisk, parted, mount, losetup 등의 utility를 이용하여 디스크 이미지를 생성, 수정, 관리하는 방법을 정리한다.
물리적인 저장 디스크 관리 Linux의 경우 저장 디스크는 block device로 /dev 디렉토리에 아래와 같은 디바이스 파일이 생성된다. 아래의 예는 sda SSD 디스크로 한 개의 파티션(sda1)이 있다.">
<meta name=application-name content="All about IoT">
<meta name=apple-mobile-web-app-title content="All about IoT">
<meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://blog.humminglab.io/posts/how-to-make-sdcard-disk-image/><link rel=prev href=https://blog.humminglab.io/posts/coap-protocol/><link rel=next href=https://blog.humminglab.io/posts/github-through-proxy/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/fontawesome-free/all.min.css>
<noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/animate/animate.min.css>
<noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"SD card 디스크 이미지 만들고 수정하는 방법 정리","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.humminglab.io\/posts\/how-to-make-sdcard-disk-image\/"},"genre":"posts","keywords":"Linux","wordcount":1624,"url":"https:\/\/blog.humminglab.io\/posts\/how-to-make-sdcard-disk-image\/","datePublished":"2017-10-25T18:00:00+09:00","dateModified":"2017-10-25T18:00:00+09:00","publisher":{"@type":"Organization","name":"HummingLab"},"authors":[{"@type":"Person","name":"YSLee"}],"description":""}</script></head>
<body header-desktop header-mobile><script type=text/javascript>function setTheme(a){document.body.setAttribute('theme',a)}function saveTheme(a){window.localStorage&&localStorage.setItem('theme',a)}function getMeta(b){const a=document.getElementsByTagName('meta');for(let c=0;c<a.length;c++)if(a[c].getAttribute('name')===b)return a[c];return''}if(window.localStorage&&localStorage.getItem('theme')){let a=localStorage.getItem('theme');a==='light'||a==='dark'||a==='black'?setTheme(a):window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light')}else''==='light'||''==='dark'||''==='black'?(setTheme(''),saveTheme('')):(saveTheme('auto'),window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light'));let metaColors={light:'#f8f8f8',dark:'#252627',black:'#000000'};getMeta('theme-color').content=metaColors[document.body.getAttribute('theme')]</script>
<div id=back-to-top></div>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="All about IoT">All about IoT</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> Posts </a><a class=menu-item href=/tags/> Tags </a><a class=menu-item href=/categories/> Categories </a><a class=menu-item href=https://www.humminglab.io/ rel="noopener noreffer" target=_blank> HummingLab </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="All about IoT">All about IoT</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=https://www.humminglab.io/ title rel="noopener noreffer" target=_blank>HummingLab</a><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>Contents</h2>
<div class="toc-content always-active" id=toc-content-auto></div>
</div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">SD card 디스크 이미지 만들고 수정하는 방법 정리</h1><div class=post-meta>
<div class=post-meta-line>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.humminglab.io/authors/yslee>YSLee</a></span>
</span>&nbsp;<span class=post-category>included in </span>&nbsp;<span class=post-category>category <a href=/categories/embedded-linux/><i class="far fa-folder fa-fw"></i>Embedded Linux</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2017-10-25>2017-10-25</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2017-10-25>2017-10-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1624 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;8 minutes&nbsp;</div>
</div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#물리적인-저장-디스크-관리>물리적인 저장 디스크 관리</a></li>
<li><a href=#디스크-이미지>디스크 이미지</a></li>
<li><a href=#mbrmaster-boot-record>MBR(Master Boot Record)</a></li>
<li><a href=#디스크-이미지-샘플>디스크 이미지 샘플</a></li>
<li><a href=#정리>정리</a></li>
</ul>
</nav></div>
</div><div class=content id=content><p><a href=https://www.yoctoproject.org target=_blank rel="noopener noreffer">Yocto Project</a>나 <a href=https://buildroot.org target=_blank rel="noopener noreffer">Buildroot</a>를 이용하여 embedded linux 시스템을 빌드하면 SD card나 MMC에 쓸수 있는 이미지까지 생성해 준다. 하지만 빌드되는 디스크 이미지 형태와 다르게 파티셔닝을 하려면 관련된 정보들을 알고 있어야 한다.</p>
<p>여기에서는 <a href=https://linux.die.net/man/1/dd target=_blank rel="noopener noreffer">dd</a>, <a href=https://linux.die.net/man/1/truncate target=_blank rel="noopener noreffer">truncate</a>, <a href=https://linux.die.net/man/8/fdisk target=_blank rel="noopener noreffer">fdisk</a>, <a href=https://www.gnu.org/software/parted/ target=_blank rel="noopener noreffer">parted</a>, <a href=https://linux.die.net/man/8/mount target=_blank rel="noopener noreffer">mount</a>, <a href=https://linux.die.net/man/8/losetup target=_blank rel="noopener noreffer">losetup</a> 등의 utility를 이용하여 디스크 이미지를 생성, 수정, 관리하는 방법을 정리한다.</p>
<h2 id=물리적인-저장-디스크-관리>물리적인 저장 디스크 관리</h2>
<p>Linux의 경우 저장 디스크는 block device로 /dev 디렉토리에 아래와 같은 디바이스 파일이 생성된다. 아래의 예는 sda SSD 디스크로 한 개의 파티션(sda1)이 있다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ ls -l /dev/sd*
brw-rw---- <span class=m>1</span> root disk 8, <span class=m>0</span> 10월 <span class=m>24</span> 13:40 /dev/sda
brw-rw---- <span class=m>1</span> root disk 8, <span class=m>1</span> 10월 <span class=m>24</span> 13:40 /dev/sda1
</code></pre></td></tr></table>
</div>
</div><p>해당 디스크의 파티션을 보거나 수정하려면 <a href=https://linux.die.net/man/8/fdisk target=_blank rel="noopener noreffer">fdisk</a>나 <a href=https://www.gnu.org/software/parted/ target=_blank rel="noopener noreffer">parted</a>를 사용할 수 있다. 일반적인 용도로 사용시에는 크게 차이는 없으나 script로 배치 작업을 하기 위하여는 parted를 사용하는 것이 좋다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ sudo parted -s /dev/sda print
Model: VMware, VMware Virtual S <span class=o>(</span>scsi<span class=o>)</span>
Disk /dev/sda: 118GB
Sector size <span class=o>(</span>logical/physical<span class=o>)</span>: 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start   End    Size   Type     File system  Flags
 <span class=m>1</span>      1049kB  118GB  118GB  primary  ext4         boot
</code></pre></td></tr></table>
</div>
</div><ul>
<li>디스크를 엑세스 하는 것이므로 root 권한 필요</li>
<li>-s: 스크립트 모드. print command를 실행</li>
</ul>
<p>생성된 파티션에 이미지를 쓰기 위하여는 dd를 이용할 수 있다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ sudo dd <span class=k>if</span><span class=o>=</span>image.ext4 <span class=nv>of</span><span class=o>=</span>/dev/sda1
</code></pre></td></tr></table>
</div>
</div><p>dd의 각각의 필드는 다음과 같다.</p>
<ul>
<li>if: input file</li>
<li>of: output file. 실제 write할 디스크 파티션</li>
</ul>
<p>dd로 쓴 파티션은 mount를 이용하여 원하는 디렉토리에 마운트하여 사용할 수 있다. 아래의 예는 EXT4 형식의 파일 시스템인 /dev/sda1를 /media 디렉토리로 마운트 한 것이다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ mount -t ext4 /dev/sda1 /media
</code></pre></td></tr></table>
</div>
</div><h2 id=디스크-이미지>디스크 이미지</h2>
<p>SD card나 MMC는 저장 방식은 다를 수 있지만 실제 사용 관점에서는 일반 하드디스크와 동일한 개념의 block device라고 보면 된다. 즉, sector 단위로 나뉘어진 공간에 읽거나 쓸수 있다.</p>
<p>초기화 되지 않은 SD card나 MMC는 위의 방법처럼 디스크에 직접 직접 쓸 수 있지만, 임베디드 시스템 개발 과정에서는 빌드 시 저장 장치에 쓸 디스크 이미지를 만들고, 이를 SD card나 MMC에 통으로 쓰는 경우도 많다.</p>
<p>이와 같은 가상의 디스크 이미지를 만드는 것도 직접 디스크에 쓰는 과정과 동일하다. 하나의 차이점이 있다면 물리적인 디스크 공간은 늘거나 줄지 않지만, 가상의 디스크 이미지는 파일 저장 공간만큼 늘리거나 줄일 수 있다는 것이다.</p>
<p>우선 필요한 만큼 파일로 공간을 할당하여야 한다. 아래 예는 1GiB 만큼의 공간을 할당하는 것이다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ dd <span class=k>if</span><span class=o>=</span>/dev/null <span class=nv>of</span><span class=o>=</span>test.img <span class=nv>bs</span><span class=o>=</span>1kx1k <span class=nv>seek</span><span class=o>=</span>1k
0+0 records in
0+0 records out
<span class=m>0</span> bytes copied, 0.000174626 s, 0.0 kB/s

$ ls -l
total <span class=m>1</span>
-rw-rw-r--  <span class=m>1</span> yslee yslee <span class=m>1073741824</span> 10월 <span class=m>24</span> 17:51 test.img
</code></pre></td></tr></table>
</div>
</div><p>dd를 이용하여 블럭디바이스에 쓰는 것이나 파일에 쓰는 것이나 동일하다고 보면 된다.</p>
<ul>
<li>if=/dev/null: 입력을 null device로 부터 받는다. 즉, 입력이 없음</li>
<li>of=test.img: test.img로 파일을 생성한다.</li>
<li>bs=1kx1x: 1KiB x 1KiB, 즉 1MiB 단위로 block size를 설정. Block size는 실제 저장 장치의 block(sector) size 가 아니라 한번에 read 또는 write 하는 단위라고 생각하면 된다.</li>
<li>seek=1k: 1KiB(1,024) 번째로 이동. 즉 1,024 * 1MiB(bs) = 1GiB 위치가 된다.</li>
</ul>
<p>위와 같이 입력이 null로 된 상태에서 seek로 위치만 설정해 주면 해당 크기만큼의 파일이 생성된다.</p>
<p>이와 같은 방식으로 생성한 파일은 <a href=https://en.wikipedia.org/wiki/Sparse_file target=_blank rel="noopener noreffer">sparse file</a>로 Unix 계열이나, NTFS에서 지원된다. Sparse file이란 실제로 해당 공간만큼 물리적인 공간에 할당하는 것이 아니라 실제로 데이타가 있는 부분만 저장하는 방식이다.</p>
<p><img class=lazyload data-src=https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/Sparse_file_%28en%29.svg/495px-Sparse_file_%28en%29.svg.png data-srcset="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/Sparse_file_%28en%29.svg/495px-Sparse_file_%28en%29.svg.png, https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/Sparse_file_%28en%29.svg/495px-Sparse_file_%28en%29.svg.png 1.5x, https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/Sparse_file_%28en%29.svg/495px-Sparse_file_%28en%29.svg.png 2x" data-sizes=auto alt=https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/Sparse_file_%28en%29.svg/495px-Sparse_file_%28en%29.svg.png title="Sparse File"></p>
<p><em>그림: Sparse Image의 개념(<a href=https://en.wikipedia.org/wiki/Sparse_file target=_blank rel="noopener noreffer">Wikipedia</a>)</em></p>
<p>실제로 디스크에 할당된 공간은 du를 이용하거나 ls의 -s 옵션을 이용하여 확인할 수 있다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ du -h test.img
<span class=m>0</span>       test.img

$ ls -lhs
4.0K -rw-rw-r--  <span class=m>1</span> yslee yslee 1.0G 10월 <span class=m>24</span> 18:05 test.img
</code></pre></td></tr></table>
</div>
</div><p><a href=https://linux.die.net/man/1/dd target=_blank rel="noopener noreffer">dd</a> 이외에도 <a href=https://linux.die.net/man/1/truncate target=_blank rel="noopener noreffer">truncate</a>를 이용하여서도 sparse file을 생성할 수 있다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ truncate -s 1G test2.img

$ ls -l
total <span class=m>2</span>
-rw-rw-r--  <span class=m>1</span> yslee yslee <span class=m>1073741824</span> 10월 <span class=m>24</span> 17:51 test.img
-rw-rw-r--  <span class=m>1</span> yslee yslee <span class=m>1073741824</span> 10월 <span class=m>24</span> 18:03 test2.img

$ du -h test2.img
<span class=m>0</span>       test2.img
</code></pre></td></tr></table>
</div>
</div><p>이와 같이 디스크 이미지로 1GiB 공간을 할당하고, block device와 동일한 방식으로 설정을 할 수 있다.
예를 들어 fdisk로 partition을 할당할 수도 있다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ fdisk test.img

Command <span class=o>(</span>m <span class=k>for</span> <span class=nb>help</span><span class=o>)</span>: n
Partition <span class=nb>type</span>
   p   primary <span class=o>(</span><span class=m>0</span> primary, <span class=m>0</span> extended, <span class=m>4</span> free<span class=o>)</span>
   e   extended <span class=o>(</span>container <span class=k>for</span> logical partitions<span class=o>)</span>
Select <span class=o>(</span>default p<span class=o>)</span>: p
Partition number <span class=o>(</span>1-4, default 1<span class=o>)</span>: <span class=m>1</span>
First sector <span class=o>(</span>2048-2097151, default 2048<span class=o>)</span>:
Last sector, +sectors or +size<span class=o>{</span>K,M,G,T,P<span class=o>}</span> <span class=o>(</span>2048-2097151, default 2097151<span class=o>)</span>:

Created a new partition <span class=m>1</span> of <span class=nb>type</span> <span class=s1>&#39;Linux&#39;</span> and of size <span class=m>1023</span> MiB.

Command <span class=o>(</span>m <span class=k>for</span> <span class=nb>help</span><span class=o>)</span>: p
Disk test.img: <span class=m>1</span> GiB, <span class=m>1073741824</span> bytes, <span class=m>2097152</span> sectors
Units: sectors of <span class=m>1</span> * <span class=nv>512</span> <span class=o>=</span> <span class=m>512</span> bytes
Sector size <span class=o>(</span>logical/physical<span class=o>)</span>: <span class=m>512</span> bytes / <span class=m>512</span> bytes
I/O size <span class=o>(</span>minimum/optimal<span class=o>)</span>: <span class=m>512</span> bytes / <span class=m>512</span> bytes
Disklabel type: dos
Disk identifier: 0x37672bca

Device     Boot Start     End Sectors  Size Id Type
test.img1        <span class=m>2048</span> <span class=m>2097151</span> <span class=m>2095104</span> 1023M <span class=m>83</span> Linux

Command <span class=o>(</span>m <span class=k>for</span> <span class=nb>help</span><span class=o>)</span>: w
The partition table has been altered.
Syncing disks.
</code></pre></td></tr></table>
</div>
</div><h2 id=mbrmaster-boot-record>MBR(Master Boot Record)</h2>
<p>디스크 파티션을 이해하기 위하여는 마스터 부트 레코드를 이해하여야 하는데, 여기에서는 필요한 부분만 간단하게 설명한다.</p>
<p>마스터 부트 레코드는 디스크의 처음 실행을 위한 코드와 파티션 분할 정보가 들어가 있는 디스크의 첫번째 sector라고 할 수 있다. 하드디스크의 섹터 크기는 512bytes이고, setctor라는 개념은 하드디스크에서 읽고 쓰기를 하는 단위로 최근의 SD card 나 MMC에서도 대부분 논리적인 개념으로 512bytes sector 단위를 사용한다 (내부적으로 write/erase block size는 이보다 더 크지만).</p>
<p>MBR에는 앞부분에 일반 PC에서 사용하던 것처럼 작은 실행 코드가 들어 갈 수 있고(PC에서만 사용하는 것으로 임베디드에서는 의미 없음), offset 0x1be 부터 16bytes씩 4개의 partiton 정보가 들어간다. 이 4개가 보통 fdisk에서 보이는 primary partition이다. 다양한 변이들이 생기면서 <a href=https://en.wikipedia.org/wiki/Master_boot_record#Sector_layout target=_blank rel="noopener noreffer">여러 버전</a>이 있지만 최소한 primary partition 위치는 동일하다. 자세한 사항은 <a href=http://thestarman.pcministry.com/asm/mbr/PartTables.htm target=_blank rel="noopener noreffer">MBR/EBR Partition Tables</a> 등을 참고 할 수 있다 (MSDOS partition이 아닌 <a href=https://en.wikipedia.org/wiki/GUID_Partition_Table target=_blank rel="noopener noreffer">GPT(GUID Partition Table)</a>등을 사용하는 경우는 여기서 설명하지 않는다).</p>
<p>SD card나 MMC의 경우 MSDOS 파티션을 사용하는 경우 마찬가지로 512bytes 단위의 섹터를 사용하고 위치를 표시하기 위하여 32bits 크기로 기록된다. 즉, MBR 섹터는 0번, 그 다음 섹터는 1번 식으로 최대 2 tera bytes까지 할당 가능(2^32 x 512bytes)하다.</p>
<p>위의 예를 든 fdisk 파티션은 2,048 섹터에서 시작해서 2,095,151 섹터까지 총 2,095,104 섹터 크기이다. 크기는 2,095,104 x 512 = 1023MiB (1,072,693,248)가 된다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>Device     Boot Start     End Sectors  Size Id Type
test.img1        2048 2097151 2095104 1023M 83 Linux
</code></pre></td></tr></table>
</div>
</div><p>dd를 이용하여 직접 파티션에 이미지를 쓸때 이 offset 정보가 필요하다.</p>
<h2 id=디스크-이미지-샘플>디스크 이미지 샘플</h2>
<p>이제 실제로 디스크 이미지를 만들어 보기로 한다.</p>
<p>dd를 이용하여 1GiB 공간의 디스크 이미지를 만든다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ dd <span class=k>if</span><span class=o>=</span>/dev/null <span class=nv>of</span><span class=o>=</span>test.img <span class=nv>bs</span><span class=o>=</span>1kx1k <span class=nv>seek</span><span class=o>=</span>1k

$ ls -l
-rw-rw-r--  <span class=m>1</span> yslee yslee <span class=m>1073741824</span> 10월 <span class=m>25</span> 17:48 test.img
</code></pre></td></tr></table>
</div>
</div><p>parted의 script를 이용하여 각각 200MiB, 나머지 전체 공간의 두 파티션을 생성한다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ parted -s test.img mklabel msdos
$ parted -s test.img mkpart primary 2048s 200MiB
$ parted -s -- test.img mkpart primary 200MiB -1s
$ parted -s test.img print
Model:  <span class=o>(</span>file<span class=o>)</span>
Disk /home/yslee/tmp/test.img: 1074MB
Sector size <span class=o>(</span>logical/physical<span class=o>)</span>: 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start   End     Size   Type     File system  Flags
 <span class=m>1</span>      1049kB  210MB   209MB  primary
 <span class=m>2</span>      210MB   1074MB  864MB  primary
</code></pre></td></tr></table>
</div>
</div><ul>
<li>line 1: MSDOS 파티션을 설정</li>
<li>line 2: 시작은 2048 sector, end를 200MiB로 파티션 할당 (리눅스 파티션)</li>
<li>line 3: 시작은 200MiB 위치, 끝까지(-1s) 할당. 중간에 double dsah(&ndash;)는 -1s 를 option 으로 처리되지 않도록 하기</li>
<li>line4: 파티션 정보 프린트</li>
</ul>
<p>디스크 이미지에 파티션 정보를 만들고, 여기에 ext4 디스크 이미지를 만들어서 dd로 복사해 보기로 한다. 디스크 이미지는 <a href=http://genext2fs.sourceforge.net target=_blank rel="noopener noreffer">genext2fs</a>와 <a href=https://linux.die.net/man/8/tune2fs target=_blank rel="noopener noreffer">tune2fs</a>로 파일로 부터 직접 이미지를 생성할 수 있으나, 여기에서는 간단하게 loop 디바이스로 마운트 하여 이미지를 생성하도록 한다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ dd <span class=k>if</span><span class=o>=</span>/dev/null <span class=nv>of</span><span class=o>=</span>test.ext4 <span class=nv>bs</span><span class=o>=</span>1kx1k <span class=nv>seek</span><span class=o>=</span><span class=m>1</span>
$ mkfs.ext4 test.ext4
$ mkdir <span class=nb>test</span>
$ sudo mount -t ext4 test.ext4 <span class=nb>test</span>
$ sudo sh -c <span class=s1>&#39;echo &#34;Hello, World!&#34; &gt; test/test.txt&#39;</span>
$ sudo umount <span class=nb>test</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>line 1: test.ext4 파일로 1MiB 이미지 생성</li>
<li>line 2: 이미지를 ext4 형식으로 초기화</li>
<li>line 3: test 디렉토리 만들기</li>
<li>line 4: 이미지를 test 디렉토리에 마운트</li>
<li>line 5: test.txt를 생성해 넣기</li>
<li>line 6: 언마운트</li>
</ul>
<p>첫번째 파티션의 시작 섹터 2,048에 ext4 이미지를 쓴다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>dd <span class=k>if</span><span class=o>=</span>test.ext4 <span class=nv>of</span><span class=o>=</span>test.img <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>seek</span><span class=o>=</span><span class=m>2048</span> <span class=nv>conv</span><span class=o>=</span>notrunc
</code></pre></td></tr></table>
</div>
</div><ul>
<li>if: 입력은 text.ext4 이미지</li>
<li>of: 쓰는 곳은 test.img</li>
<li>bs: 블럭 크기를 sector 크기로 설정</li>
<li>seek: 2048s 에 쓰기</li>
<li>conv=notrunc: 파일 형식의 이미지에 유효한 것으로, open()함수의 O_TRUNC flag를 끄기. 만일 이 옵션을 주지 않으면 결과 파일인 test.img는 모두 삭제된 후(O_TRUNC)에 입력이 써지게 된다. notrunc 옵션을 주면 overwrite이다. 일반 block device에서는 이렇게 크기가 줄어들 일이 없어 사용치 않는다.</li>
</ul>
<p>이제 만들어진 이미지를 SD card에 dd로 write를 한 후에 확인을 해보아도 되나 loop device로 마운트 하여 확인할 수 있다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ sudo losetup -Pf --show test.img
/dev/loop0

$ ls -l /dev/loop0*
brw-rw---- <span class=m>1</span> root disk   7, <span class=m>0</span> 10월 <span class=m>25</span> 18:32 /dev/loop0
brw-rw---- <span class=m>1</span> root disk 259, <span class=m>0</span> 10월 <span class=m>25</span> 18:32 /dev/loop0p1
brw-rw---- <span class=m>1</span> root disk 259, <span class=m>1</span> 10월 <span class=m>25</span> 18:32 /dev/loop0p2
</code></pre></td></tr></table>
</div>
</div><p>위와 같이 하면 loop 디바이스를 이용하여 이미지를 attach 할 수 있다. 즉, ls 를 해보면 위처럼 loop0으로 시작하는 디바이스가 생성된다. loop0은 이미지, loop0p1은 첫번째 파티션, loop0p2는 두번째 파티션이다.</p>
<p>첫번째 파티션을 마운트 해서 확인해 본다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ sudo mount -t ext4 /dev/loop0p1 <span class=nb>test</span>
$ ls test/
lost+found  test.txt
$ cat test/test.txt
Hello, World!
</code></pre></td></tr></table>
</div>
</div><p>아까 test.img의 첫번째 파티션에 쓴 파일이 정상적으로 보여진다.</p>
<p>이런 식으로 해서 직접 이미지를 쓰는 것도 가능하다. 아래는 두번째 파티션을 초기화 하고 쓰는 예이다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ sudo mkfs.ext4 /dev/loop0p2
$ mkdir test2
$ sudo mount -t ext4 /dev/loop0p2 test2
$ sudo sh -c <span class=s1>&#39;echo &#34;Test2&#34; &gt; test2/test2.txt&#39;</span>
$ ls -l test2/test2.txt
-rw-r--r-- <span class=m>1</span> root root <span class=m>6</span> 10월 <span class=m>25</span> 18:39 test2/test2.txt
</code></pre></td></tr></table>
</div>
</div><ul>
<li>line 1: 두번째 파티션을 mkfs.ext4를 이용하여 포멧</li>
<li>line 2: 시험용 test2 디렉토리 만들기</li>
<li>line 3: test2에 두번째 파티션 마운트</li>
<li>line 4: 파일 쓰기</li>
</ul>
<p>최종적으로 마운트를 종료한다.</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-sh data-lang=sh>$ sudo umount test2
$ sudo umount <span class=nb>test</span>
$ sudo losetup -D
</code></pre></td></tr></table>
</div>
</div><ul>
<li>line 3: 이전에 losetup으로 attach 한 것을 모두 detach 한다.</li>
</ul>
<p>이 과정을 거치게 되면 최종적으로 test.img에는 두개의 파티션이 각각 ext4로 초기화 되고, 첫번째 파티션에는 &ldquo;Hello, World!&rdquo; 내용의 test.txt가 두번째 파티션에는 &ldquo;Test2&rdquo; 내용의 test2.txt 파일이 있다.</p>
<h2 id=정리>정리</h2>
<p>디스크 이미지를 만드는 것이 복잡해 보이나, 실제 위의 예를 보면 일반 디스크를 포멧, 마운트 하는 과정과 큰 차이가 없다는 것을 알 수 있다.</p>
<p>이 정도를 알면 디스크 이미지를 생성하거나 수정하는 것을 마음대로 할 수 있을 것이다.</p>
</div>
<div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>Updated on 2017-10-25</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md></div>
<div class=post-info-share>
<span></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/linux/>Linux</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span>
</section>
</div>
<div class=post-nav><a href=/posts/coap-protocol/ class=prev rel=prev title="CoAP Protocol"><i class="fas fa-angle-left fa-fw"></i>CoAP Protocol</a>
<a href=/posts/github-through-proxy/ class=next rel=next title="GitHub 연결이 제대로 안될 때 proxy 사용하기">GitHub 연결이 제대로 안될 때 proxy 사용하기<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id=comments><div id=giscus></div><noscript>
Please enable JavaScript to view the comments powered by <a href=https://giscus.app/>giscus</a>.
</noscript></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://www.humminglab.io target=_blank rel="noopener noreferrer">HummingLab</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
</div></footer></div>
<div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top">
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments">
<i class="fas fa-comment fa-fw"></i>
</a>
</div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-83257319-3',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-83257319-3" async></script></div>
<div class=pjax-assets><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{giscus:{darkTheme:"dark",dataCategory:"Announcements",dataCategoryId:"DIC_kwDOGdk00s4CAGXN",dataEmitMetadata:"0",dataMapping:"pathname",dataReactionsEnabled:"1",dataRepo:"humminglab/blog.humminglab.io",dataRepoId:"R_kgDOGdk00g",lightTheme:"light"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/katex/katex.min.css>
<noscript><link rel=stylesheet href=/lib/katex/katex.min.css></noscript><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/katex/copy-tex.min.css>
<noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript></div>
</body>
</html>