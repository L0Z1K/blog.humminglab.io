<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>TLS/암호 알고리즘 쉽게 이해하기(4) - Block Cipher Mode - All about IoT</title><meta name=Description content><meta property="og:url" content="https://blog.humminglab.io/posts/tls-cryptography-4-block-cipher-mode/">
<meta property="og:site_name" content="All about IoT"><meta property="og:title" content="TLS/암호 알고리즘 쉽게 이해하기(4) - Block Cipher Mode"><meta property="og:description" content="이전 글의 Block Cipher(블럭암호) 암호화 방법을 그대로 사용하기에는 몇가지 문제가 있다 (아래 내용에서는 AES로 표기하나, 다른 블럭암호 방식에 공통적인 사항이다).
우선 첫번째 문제는 공격자가 암호키를 몰라도 암호 블럭을 순서를 바꾸어나 다른 내용으로 바꿀 수 있다는 것이다. AES 암호의 경우 128bits(16bytes) 단위로 암호화 되는데, 예를 들어 다음과 같은 거래 정보를 암호화 한다고 해보자.
1 2 3 4 5 6 7 8 9 10 11 struct { char from[16]; char to[16]; char amount[16]; } transaction; struct transaction tx = { ."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-28T19:00:00+09:00"><meta property="article:modified_time" content="2022-04-25T20:00:00+09:00"><meta property="article:tag" content="Cryptography, AES, HMAC"><meta property="og:see_also" content="https://blog.humminglab.io/posts/tls-cryptography-14-x509/"><meta property="og:see_also" content="https://blog.humminglab.io/posts/tls-cryptography-13-mac-aead/"><meta property="og:see_also" content="https://blog.humminglab.io/posts/tls-cryptography-12-ecc2/"><meta property="og:see_also" content="https://blog.humminglab.io/posts/tls-cryptography-11-ecc/"><meta property="og:see_also" content="https://blog.humminglab.io/posts/tls-cryptography-10-hash/"><meta property="og:see_also" content="https://blog.humminglab.io/posts/tls-cryptography-9-dsa/"><meta property="og:see_also" content="https://blog.humminglab.io/posts/tls-cryptography-8-rsa/"><meta name=twitter:card content="summary"><meta name=twitter:title content="TLS/암호 알고리즘 쉽게 이해하기(4) - Block Cipher Mode"><meta name=twitter:description content="이전 글의 Block Cipher(블럭암호) 암호화 방법을 그대로 사용하기에는 몇가지 문제가 있다 (아래 내용에서는 AES로 표기하나, 다른 블럭암호 방식에 공통적인 사항이다).
우선 첫번째 문제는 공격자가 암호키를 몰라도 암호 블럭을 순서를 바꾸어나 다른 내용으로 바꿀 수 있다는 것이다. AES 암호의 경우 128bits(16bytes) 단위로 암호화 되는데, 예를 들어 다음과 같은 거래 정보를 암호화 한다고 해보자.
1 2 3 4 5 6 7 8 9 10 11 struct { char from[16]; char to[16]; char amount[16]; } transaction; struct transaction tx = { ."><meta name=application-name content="All about IoT"><meta name=apple-mobile-web-app-title content="All about IoT"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://blog.humminglab.io/posts/tls-cryptography-4-block-cipher-mode/><link rel=prev href=https://blog.humminglab.io/posts/tls-cryptography-3-block-cipher/><link rel=next href=https://blog.humminglab.io/posts/tls-cryptography-5-stream-cipher/><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/color.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"TLS/암호 알고리즘 쉽게 이해하기(4) - Block Cipher Mode","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.humminglab.io\/posts\/tls-cryptography-4-block-cipher-mode\/"},"genre":"posts","keywords":"Cryptography, AES, HMAC","wordcount":1189,"url":"https:\/\/blog.humminglab.io\/posts\/tls-cryptography-4-block-cipher-mode\/","datePublished":"2022-02-28T19:00:00+09:00","dateModified":"2022-04-25T20:00:00+09:00","publisher":{"@type":"Organization","name":"HummingLab"},"authors":[{"@type":"Person","name":"YSLee"}],"description":""}</script><script src=//instant.page/5.2.0 defer type=module integrity=sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z></script></head><body header-desktop header-mobile><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else""==="light"||""==="dark"||""==="black"?(setTheme(""),saveTheme("")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="All about IoT">All about IoT</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=https://www.humminglab.io/ rel="noopener noreferrer" target=_blank>HummingLab </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="All about IoT">All about IoT</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=https://www.humminglab.io/ title rel="noopener noreferrer" target=_blank>HummingLab</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#aes-ecb>AES-ECB (Electronic Code Book)</a></li><li><a href=#aes-cbc>AES-CBC (Cipher Block Chaining)</a></li><li><a href=#aes-ctr-counter>AES-CTR (Counter)</a></li><li><a href=#정리>정리</a></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">TLS/암호 알고리즘 쉽게 이해하기(4) - Block Cipher Mode</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><span class="author fas fa-user-circle fa-fw"></span><span class=screen-reader-text> </span><a href=https://blog.humminglab.io/authors/yslee>YSLee</a></span>
</span>&nbsp;<span class=post-category>included in </span>&nbsp;<span class=post-category>category <a href=/categories/security/><i class="far fa-folder fa-fw"></i>Security</a></span>&nbsp;<span class=post-category>and</span>&nbsp;<span class=post-series>series <a href=/series/tls/%EC%95%94%ED%98%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/><i class="far fa-list-alt fa-fw"></i>TLS/암호 알고리즘 쉽게 이해하기</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-02-28>2022-02-28</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2022-04-25>2022-04-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1189 words&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;6 minutes&nbsp;</div></div><div class="details series-nav open"><div class="details-summary series-title"><span>Series - </span><span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content series-content"><nav><ul><li><a href=/posts/tls-cryptography-14-x509/>TLS/암호 알고리즘 쉽게 이해하기(14) - PKI and X.509</a></li><li><a href=/posts/tls-cryptography-13-mac-aead/>TLS/암호 알고리즘 쉽게 이해하기(13) - MAC, AE, AEAD</a></li><li><a href=/posts/tls-cryptography-12-ecc2/>TLS/암호 알고리즘 쉽게 이해하기(12) - ECDH, ECDSA</a></li><li><a href=/posts/tls-cryptography-11-ecc/>TLS/암호 알고리즘 쉽게 이해하기(11) - Elliptic Curve Cryptography(ECC)</a></li><li><a href=/posts/tls-cryptography-10-hash/>TLS/암호 알고리즘 쉽게 이해하기(10) - Hash</a></li><li><a href=/posts/tls-cryptography-9-dsa/>TLS/암호 알고리즘 쉽게 이해하기(9) - Digital Signature</a></li><li><a href=/posts/tls-cryptography-8-rsa/>TLS/암호 알고리즘 쉽게 이해하기(8) - RSA</a></li><li><a href=/posts/tls-cryptography-7-diffie-hellman/>TLS/암호 알고리즘 쉽게 이해하기(7) - Diffie-Hellman Key Exchange</a></li><li><a href=/posts/tls-cryptography-6-math/>TLS/암호 알고리즘 쉽게 이해하기(6) - 이산 대수</a></li><li><a href=/posts/tls-cryptography-5-stream-cipher/>TLS/암호 알고리즘 쉽게 이해하기(5) - Stream Cipher</a></li><li><span class=active>TLS/암호 알고리즘 쉽게 이해하기(4) - Block Cipher Mode</span></li><li><a href=/posts/tls-cryptography-3-block-cipher/>TLS/암호 알고리즘 쉽게 이해하기(3) - Block Cipher</a></li><li><a href=/posts/tls-cryptography-2-random/>TLS/암호 알고리즘 쉽게 이해하기(2) - Random</a></li><li><a href=/posts/tls-cryptography-1-overview/>TLS/암호 알고리즘 쉽게 이해하기(1) - 개요</a></li></ul></nav></div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#aes-ecb>AES-ECB (Electronic Code Book)</a></li><li><a href=#aes-cbc>AES-CBC (Cipher Block Chaining)</a></li><li><a href=#aes-ctr-counter>AES-CTR (Counter)</a></li><li><a href=#정리>정리</a></li></ul></nav></div></div><div class=content id=content><p>이전 글의 <a href=https://blog.humminglab.io/posts/tls-cryptography-3-block-cipher/ rel>Block Cipher(블럭암호)</a> 암호화 방법을 그대로 사용하기에는 몇가지 문제가 있다
(아래 내용에서는 AES로 표기하나, 다른 블럭암호 방식에 공통적인 사항이다).</p><p>우선 첫번째 문제는 공격자가 암호키를 몰라도 암호 블럭을 순서를 바꾸어나 다른 내용으로 바꿀 수 있다는 것이다.
AES 암호의 경우 128bits(16bytes) 단위로 암호화 되는데, 예를 들어 다음과 같은 거래 정보를 암호화 한다고 해보자.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>from</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>to</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>amount</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>transaction</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>transaction</span> <span class=n>tx</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>from</span> <span class=o>=</span> <span class=s>&#34;Alice&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>to</span> <span class=o>=</span> <span class=s>&#34;Bob&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>amount</span> <span class=o>=</span> <span class=s>&#34;100&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>이를 AES로 암호를 하게 되면 16bytes 3개의 암호 블럭이 생성된다(<a href=https://blog.humminglab.io/posts/tls-cryptography-3-block-cipher/#Padding rel>패딩</a>을 하지 않는 경우). 만일 공격자가 이 블럭 순서 1,2,3을 2,1,3 으로 바꾸게 되면 from, to 가 바뀌어 거래가 반대로 되어 버린다.
또는 이전의 다른 거래내역에서 금액 부분을 저장해 두었다가 이것으로 교체하게 되면 거래 금액이 달라지게 된다.</p><p>두번째 문제는 재전송 공격이 가능하다는 것이다. 공격자가 위 메시지를 전체를 저장해 두었다가 다시 전송하게 되면 2번의 거래가 이루어 지게 된다.</p><p>다른 것들도 있지만 우선은 이 두가지 문제만 고려해보자.</p><p>첫번째 문제를 막을 수 있는 방법은 1,2,3 세개의 블럭을 서로 연결 시키는 방법이다. 예를 들어서 1,2,3 순번을 데이터와 같이 암호 시에 추가할 수 있다.
두번째 문제를 해결하기 위하여는 매 트랜젝션 마다 임의의 난수를 생성하여 이를 같이 암호화 하는 방법이 있다. 이렇게 하면 동일한 데이타를 암호화 하더라도 매번 다른 결과가 나오게 된다.</p><p>이와 같은 운용 모드로 다음과 같은 것이 있다.</p><ul><li>AES-ECB (Electronic Code Book)</li><li>AES-CBC (Cipher Block Chaining)</li><li>AES-CTR (Counter)</li></ul><p>아래 설명에 있는 그림은 모두 <a href=https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation target=_blank rel="noopener noreferrer">Wikipedia - Block cipher mode of operation</a> 에 있는 그림이다.
조금 더 자세한 설명은 위키피디아 페이지를 참고할 수 있다.</p><p>위키피디아나 다른 문서를 보면 AES-CFB(Cipher FeedBack), AES-OFB(Output FeedBack) 등 다른 방법도 설명하고 있으나, 해당 방식들은 책에서만 있지 실사용은 거의 없는 방법들이다. 여기에서는 이들 방식은 언급하지 않는다.</p><h2 id=aes-ecb class=headerLink><a href=#aes-ecb class=header-mark></a>AES-ECB (Electronic Code Book)</h2><p>ECB 모드는 모드라고 말하기가 그렇다. 그냥 아무것도 하지 않고 AES 암호화 / 복호화를 하는 것이다.
실제로는 이와 같은 모드를 사용할 일은 거의 없다고 보아도 된다.</p><figure><img src=/posts/tls-cryptography-4-block-cipher-mode/1202px-ECB_encryption.svg.png width=600px height=auto></figure><figure><img src=/posts/tls-cryptography-4-block-cipher-mode/1202px-ECB_decryption.svg.png width=600px height=auto></figure><p>AES-128 로 ECB 모드를 암호화 하는 예를 들어 보자. 테스트는 리눅스 환경에서 실행하여야 한다.</p><p>실제 암호화 되는 패턴을 보면 다음과 같다.</p><ul><li>dd 를 이용하여 2개의 AES 블럭이 되는 36bytes 데이타를 생성한다. 이를 8진수 020 (십육진수 0x10) 으로 tr 로 변경하여 input.bin 으로 저장한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ dd <span class=k>if</span><span class=o>=</span>/dev/zero  <span class=nv>bs</span><span class=o>=</span><span class=m>16</span> <span class=nv>count</span><span class=o>=</span><span class=m>2</span> <span class=p>|</span> tr <span class=s2>&#34;\0&#34;</span> <span class=s2>&#34;\020&#34;</span> &gt; input.bin
</span></span><span class=line><span class=cl>$ hexdump -v input.bin
</span></span><span class=line><span class=cl><span class=m>0000000</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span>
</span></span><span class=line><span class=cl><span class=m>0000010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>이를 openssl CLI를 이용하여 AES-128 ECB 모드로 암호화 한다.<ul><li>AES-128 은 128bit 키를 사용하고, 여기에서는 hexadecimal 로 &ldquo;000102030405060708090a0b0c0d0e0f&rdquo; 로 입력하였다.</li><li>&lsquo;-nopad&rsquo; 로 추가적인 패딩을 하지 않도록 함.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl aes-128-ecb -e -in input.bin -K 000102030405060708090a0b0c0d0e0f -nopad <span class=p>|</span> hexdump -v
</span></span><span class=line><span class=cl><span class=m>0000000</span> 4f95 f264 e8e4 9e6e 82ee 02d2 <span class=m>6816</span> <span class=m>9948</span>
</span></span><span class=line><span class=cl><span class=m>0000010</span> 4f95 f264 e8e4 9e6e 82ee 02d2 <span class=m>6816</span> <span class=m>9948</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>결과를 보면 0x10 으로 채워진 2개의 블럭은 암호화시 동일한 결과를 가진다.</p></li><li><p>&lsquo;-nopad&rsquo; 옵션을 빼고 암호화를 하면 다음과 같다.</p><ul><li>암호화 결과가 동일한 한개의 블럭이 더 추가되었는데, 이유는 데이타가 16bytes로 나누어 떨어지는 경우 0x10 으로 추가 한블럭의 padding이 추가 되기 때문이다. 관련 설명은 이전글 <a href=https://blog.humminglab.io/posts/tls-cryptography-3-block-cipher/#Padding rel>패딩</a> 을 참고할 수 있다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl aes-128-ecb -e -in input.bin -K 000102030405060708090a0b0c0d0e0f <span class=p>|</span> hexdump -v
</span></span><span class=line><span class=cl><span class=m>0000000</span> 4f95 f264 e8e4 9e6e 82ee 02d2 <span class=m>6816</span> <span class=m>9948</span>
</span></span><span class=line><span class=cl><span class=m>0000010</span> 4f95 f264 e8e4 9e6e 82ee 02d2 <span class=m>6816</span> <span class=m>9948</span>
</span></span><span class=line><span class=cl><span class=m>0000020</span> 4f95 f264 e8e4 9e6e 82ee 02d2 <span class=m>6816</span> <span class=m>9948</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>암호화 한것을 다시 복호화 해보면 정상적으로 복호화 되는 것을 확인할 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl aes-128-ecb -e -in input.bin -K 000102030405060708090a0b0c0d0e0f <span class=p>|</span> openssl aes-128-ecb -d -K 000102030405060708090a0b0c0d0e0f <span class=p>|</span>
</span></span><span class=line><span class=cl> hexdump -v
</span></span><span class=line><span class=cl><span class=m>0000000</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span>
</span></span><span class=line><span class=cl><span class=m>0000010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span> <span class=m>1010</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=aes-cbc class=headerLink><a href=#aes-cbc class=header-mark></a>AES-CBC (Cipher Block Chaining)</h2><p>AES-ECB 방식에 다음과 같은 2가지 사항이 추가되었다.</p><ul><li>IV(Initialization Vector)라는 초기 랜덤값을 추가하여 동일한 데이타에 대해서도 다른 암호화 결과가 나오도록 함</li><li>앞 블럭의 암호화 결과를 다음 블럭을 암호화 할때 XOR 하여 체인으로 연결</li></ul><figure><img src=/posts/tls-cryptography-4-block-cipher-mode/1200px-CBC_encryption.svg.png width=600px height=auto></figure><figure><img src=/posts/tls-cryptography-4-block-cipher-mode/1200px-CBC_decryption.svg.png width=600px height=auto></figure><p>XOR의 경우 동일한 XOR를 반복하는 경우 다시 원래의 데이터가 되는 특성이 있어, 이를 사용한 것이다. 암호화 시에는 먼저, 복호화 시 암호화 절차와 반대로 뒷 부분에 XOR를 해준다.</p><p>통신 시, 클라이언트나 서버, 또는 둘 모두 에서 생성한 랜덤값을 IV로 사용하여 통신을 하게되면, 동일한 데이타를 보내도 다른 암호 결과값이 되고, 데이타 순서가 바뀌는 경우에도 정상적으로 복호화 되지 않아 처음에 언급한 두 가지 문제를 해결할 수 있다.</p><p>OpenSSL로 암호화 되는 패턴을 보면 다음과 같다.</p><ul><li>IV를 0 으로 해서 실행해보면 첫 블럭은 AES-ECB 방식을 사용한 것과 동일하다. 하지만 두번째 블럭은 앞 블럭의 암호화 결과가 XOR 되어 암호화 결과가 다른 값이 된다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl aes-128-cbc -e -in input.bin -K 000102030405060708090a0b0c0d0e0f -nopad -iv <span class=m>00000000000000000000000000000000</span> <span class=p>|</span> hexdump -v
</span></span><span class=line><span class=cl><span class=m>0000000</span> 4f95 f264 e8e4 9e6e 82ee 02d2 <span class=m>6816</span> <span class=m>9948</span>
</span></span><span class=line><span class=cl><span class=m>0000010</span> 93db 8ae4 f2e2 <span class=m>6326</span> 3ce6 38df cd70 a808
</span></span></code></pre></td></tr></table></div></div><p>하지만 이 방식은 다음과 같은 단점이 있다.</p><ul><li>구조적으로 병렬화가 되지 않아 성능이 떨어진다. 암호화시 앞 블럭의 결과가 나와야만 다음 블럭을 암호화 할수 있으므로 멀티 프로세서를 사용한 병렬화가 불가능하다.</li><li>패딩과 복호화 시 XOR 가 뒤에 있는 구조로 인하여, 패딩 오라클 공격에 취약할 수 있다.</li></ul><p>오라클 공격에 대해서는 아래 첫번째 블로그를 보면 이해하기 쉽게 원리가 설명되어 있고, 두번째 링크에서는 이를 기반으로한 다양한 공격 방법들에 대해서 찾아 볼 수 있다.</p><ul><li><a href=https://bperhaps.tistory.com/entry/%EC%98%A4%EB%9D%BC%ED%81%B4-%ED%8C%A8%EB%94%A9-%EA%B3%B5%EA%B2%A9-%EA%B8%B0%EC%B4%88-%EC%84%A4%EB%AA%85-Oracle-Padding-Attack target=_blank rel="noopener noreferrer">오라클 패딩 공격 기초 설명</a></li><li><a href=https://www.ietf.org/proceedings/89/slides/slides-89-irtfopen-1.pdf target=_blank rel="noopener noreferrer">Lucky 13, BEAST, CRIME,&mldr; Is TLS dead, or just resting?</a></li></ul><p>참고로 AES-CBC 모드는 데이타 검증을 위한 HMAC 과 같이 사용하면 이와 같은 공격에 대한 방어를 할 수 있고, TLS 1.2 에서도 이를 사용하고 있다.
하지만 TLS 1.3 에서는 AES-CBC 가 제외 되었고, AES-GCM 를 사용하여야 한다. 이는 나중에 MAC 관련된 부분에서 다시 설명키로 한다.</p><h2 id=aes-ctr-counter class=headerLink><a href=#aes-ctr-counter class=header-mark></a>AES-CTR (Counter)</h2><p>CTR 모드는 CBC 모드와 달리 AES를 이용하여 데이타를 암호화 하는 것이 아니라, Nonce 와 Counter 값을 암호화 후, 이의 결과 값과 평문을 XOR 로 암호화 한다.</p><p>참고로 Stream 암호화에서도 다시 언급하겠지만, 완전한 난수열와 XOR를 한 데이타는 난수열을 알지 못하는 이상 어떤 방식으로든 푸는 것이 불가능하다.</p><p><figure><img src=/posts/tls-cryptography-4-block-cipher-mode/1202px-CTR_encryption_2.svg.png width=600px height=auto></figure><figure><img src=/posts/tls-cryptography-4-block-cipher-mode/1202px-CTR_decryption_2.svg.png width=600px height=auto></figure></p><p>이와 같은 방식으로 하면 다음과 같은 장점이 생긴다.</p><ul><li>CBC와는 달리 이전 블럭과 직접적인 상관 관계가 없어 병렬화가 가능하다.</li><li>블럭 암호화이기도 하지만 그림을 잘 보면 스트림 암호화이기도 하다. (Nonce || Counter)를 암호화한 난수열로 plaintext가 암호화 되는 stream 암호화이기도 하다.</li><li>스트림 암호이므로 별도의 패딩이 필요없다. 필요한 바이트만 암호화/복호화 하면 된다.</li></ul><p>동작 확인은 다음과 같이 해볼 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl enc -aes-128-ctr -in input.bin -K 000102030405060708090a0b0c0d0e0f -iv <span class=m>00000000000000000000000000000000</span> <span class=p>|</span> hexdump -v
</span></span><span class=line><span class=cl><span class=m>0000000</span> b1d6 272b 9f97 924b 5f7f <span class=m>7291</span> d8b1 69c8
</span></span><span class=line><span class=cl><span class=m>0000010</span> <span class=m>5663</span> <span class=m>8503</span> d085 0ea4 6b59 f3ad e475 1a3d
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ openssl enc -aes-128-ctr -in input.bin -K 000102030405060708090a0b0c0d0e0f -iv <span class=m>00000000000000000000000000000001</span> <span class=p>|</span> hexdump -v
</span></span><span class=line><span class=cl><span class=m>0000000</span> <span class=m>5663</span> <span class=m>8503</span> d085 0ea4 6b59 f3ad e475 1a3d
</span></span><span class=line><span class=cl><span class=m>0000010</span> c659 <span class=m>4397</span> 8b89 9cb6 99f3 786a <span class=m>9170</span> 8da0
</span></span></code></pre></td></tr></table></div></div><p>위의 결과를 보면 IV가 0인 경우의 두번째 블럭(counter가 1이 되는)과 IV가 1인 경우의 첫번째 블럭이 동일하게 암호화 된다. OpenSSL 에서는 IV $\oplus$ Counter 와 같이 XOR 하여 이를 키로 암호화 하는 것을 확인할 수 있다.</p><p>아래와 같이 AES 블럭 단위인 16바이트가 아니어도 암호화 가능하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ dd <span class=k>if</span><span class=o>=</span>/dev/zero  <span class=nv>bs</span><span class=o>=</span><span class=m>8</span> <span class=nv>count</span><span class=o>=</span><span class=m>1</span> <span class=p>|</span> tr <span class=s2>&#34;\0&#34;</span> <span class=s2>&#34;\020&#34;</span> &gt; input2.bin
</span></span><span class=line><span class=cl>$ openssl enc -aes-128-ctr -in input2.bin -K 000102030405060708090a0b0c0d0e0f -iv <span class=m>00000000000000000000000000000000</span> <span class=p>|</span> hexdump -v
</span></span><span class=line><span class=cl><span class=m>0000000</span> b1d6 272b 9f97 924b
</span></span></code></pre></td></tr></table></div></div><h2 id=정리 class=headerLink><a href=#%ec%a0%95%eb%a6%ac class=header-mark></a>정리</h2><p>이상으로 블럭 암호화 방식의 운용 모드에 대해서 정리해 보았다.</p><p>이 방식들은 처음에 언급한 것과 같이 암호화한 데이타의 조작이나, 재사용을 방지하기 위한 방법이다. 하지만 이 방식은 정상적인 데이터 인지는 확인할 수 없다. Hash 등을 이용한 체크섬이 추가된다면 이에 대한 보완이 될 것이다. 암호화에서는 key가 추가된 hash 방식인 HMAC(Hash-based Message Authentication Code)와 같이 사용한다. 이 부분은 다음에 설명키로 하고 블럭암호화 모드는 이것으로 마무리한다.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-04-25</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href></a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/tls-cryptography-3-block-cipher/ class=prev rel=prev title="TLS/암호 알고리즘 쉽게 이해하기(3) - Block Cipher"><i class="fas fa-angle-left fa-fw"></i>TLS/암호 알고리즘 쉽게 이해하기(3) - Block Cipher</a>
<a href=/posts/tls-cryptography-5-stream-cipher/ class=next rel=next title="TLS/암호 알고리즘 쉽게 이해하기(5) - Stream Cipher">TLS/암호 알고리즘 쉽게 이해하기(5) - Stream Cipher<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=giscus></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/>giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://www.humminglab.io target=_blank rel="noopener noreferrer">HummingLab</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{giscus:{darkTheme:"dark",dataCategory:"Announcements",dataCategoryId:"DIC_kwDOGdk00s4CAGXN",dataEmitMetadata:"0",dataInputPosition:"bottom",dataLang:"en",dataMapping:"pathname",dataReactionsEnabled:"1",dataRepo:"humminglab/blog.humminglab.io",dataRepoId:"R_kgDOGdk00g",dataStrict:"0",lightTheme:"light"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js defer></script><script type=text/javascript src=/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/js/katex.min.js defer></script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript src=/js/giscus.min.js defer></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-83257319-3",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-83257319-3" async></script></div></body></html>