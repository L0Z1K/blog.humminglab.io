<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - All about IoT</title><link>https://blog.humminglab.io/posts/</link><description>All Posts | All about IoT</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 07 Jan 2022 19:00:00 +0900</lastBuildDate><atom:link href="https://blog.humminglab.io/posts/" rel="self" type="application/rss+xml"/><item><title>Yocto Project 개발하기(2) - Custom Layer 만들기</title><link>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/</link><pubDate>Fri, 07 Jan 2022 19:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orange-pi-2/</guid><description>이전 글 에서 meta-sunxi 를 추가하여 orage pi 용으로 빌드를 만들었고, 이번 과정은 project 용으로 meta layer를 만들어서 관리하는 방법을 설명한다.
실제 개발 과정을 이해하기 좋도록 meta layer 를 만들어 가는 과정을 설명한다.
Yocto Project 개발하기(1) - Orange Pi 보드 빌드 Yocto Project 개발하기(2) - Custom Layer 만들기 Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기 Yocto Project 개발하기(4) - Yocto SDK 빌드 Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델 Layer 및 machine 생성 프로젝트를 sc-gateway 라고 명하고(이름에 특별한 의미는 없음), 이를 layer로 만든다.</description></item><item><title>Nearley 로 설정용 파서 만들기</title><link>https://blog.humminglab.io/posts/nearley-builder-and-loader/</link><pubDate>Tue, 04 Jan 2022 19:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/nearley-builder-and-loader/</guid><description>이 문서에서는 Nearley parsing toolkit 을 이용하여 IoT 기기에서 사용할 설정 정보의 binary pack 및 loader 를 생성하는 방법을 설명한다.
예를 들어 아래와 같은 간단한 문법을 정의하고, 이를 Nearley 로 parser를 만들어 구분 분석을 하여, 디바이스에 로드할 수 있는 바이너리 데이터로 변환을 한다. 그리고, 변환된 바이너리 파일을 장치에서 로드하여 설정 정보를 얻는다.
1 2 3 4 5 6 7 topic/test1 { temperature I8; humidity U8; pressure U16; timestamp U32; name STR[12]; } 배경 아래 그림과 같이 IoT 기기는 기기 고유의 컨트롤을 담당하는 Host MCU와 별도의 Wi-Fi 모듈로 IoT 기능을 구현하는 경우가 많다.</description></item><item><title>Yocto Project 개발하기(1) - Orange Pi 보드 빌드</title><link>https://blog.humminglab.io/posts/yocto-project-on-orage-pi-1/</link><pubDate>Thu, 30 Dec 2021 22:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-on-orage-pi-1/</guid><description>이 문서는 Orange Pi Zero 보드에서 Yocto Project를 이용하여 배포본을 만들고, 개별 패키지를 관리하는 방법에 대하여 설명한다.
설명은 다음과 같이 나누어서 설명을 할 에정이다.
Yocto Project 개발하기(1) - Orange Pi 보드 빌드 Yocto Project 개발하기(2) - Custom Layer 만들기 Yocto Project 개발하기(3) - 개발 시 로컬 패키지 관리하기 Yocto Project 개발하기(4) - Yocto SDK 빌드 Yocto Project 개발하기(5) - Yocto eSDK 이용한 개발 모델 이 문서에서는 첫번째 과정인 필요한 layer를 추가해서 빌드하여 타겟에 올려서 동작을 확인하는 과정을 설명한다.</description></item><item><title>Wireshark 으로 TLS 캡쳐 및 디코딩 하기</title><link>https://blog.humminglab.io/posts/how-to-capture-tls-with-wireshark/</link><pubDate>Tue, 21 Dec 2021 16:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/how-to-capture-tls-with-wireshark/</guid><description>프로토콜을 개발하거나 검증하려고 할 때 SSL/TLS 암호화 채널로 전송되는 데이타를 디코딩하여 확인이 필요할 때가 있다. 이 글에서는 시험하려는 프로그램의 수정 없이 또는 최소한의 수정으로 디코딩 하는 방법을 설명한다.
개요 TLS 채널의 초기 셋업 절차는 크게 보면 다음과 같은 절차로 이루어진다.
서버 인증서를 받아서 검증하기 필요하면 클라이언트 인증서를 받아서 검증하기 암호화 방식을 이용하여 대칭키 교환 대칭키를 이용한 암호화된 데이타 송수신 패킷을 분석하기에 필요한 사항은 결국은 위 세번째 과정에서 교환한 대칭키(Master Secret)를 얻는 것이다.</description></item><item><title>OCI, WireGuard 로 무료 공인 IPv6 주소 사용하기</title><link>https://blog.humminglab.io/posts/how-to-oci-wireguard-public-ipv6/</link><pubDate>Fri, 10 Dec 2021 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/how-to-oci-wireguard-public-ipv6/</guid><description>IPv6 서비스를 개발하거나 시험하려는 경우 국내에서 기업용 인터넷이 아닌 경우에는 IPv6 주소를 이용하기가 쉽지 않다. IPv4 주소만 제공하는 가정용 인터넷이나 LTE 망에서 Oracle Cloud Infrastruct(OCI) Free Tier 를 사용하여 무료로 공인 IPv6 망을 구성하는 방법을 설명한다.
시스템 구성" 시스템 구성 다른 방법들 공인 IPv6 를 할당받는 가장 쉬운 방법은 IPv6 TunnelBrokwer 를 이용하는 것이다. 미국 ISP 업체인 Hurricane Electric 에서 제공하는 Tunnel Broker는 아래 주소로 접속하여 가입하면 무료로 IPv6 주소를 할당 받아 사용할 수 있다.</description></item><item><title>Yocto Project History</title><link>https://blog.humminglab.io/posts/yocto-project-history/</link><pubDate>Sun, 06 Jan 2019 09:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/yocto-project-history/</guid><description>Yocto Project를 보면 OpenEmbedded, bitbake, poky 와 같은 용어들이 나온다. Bitbake는 Yocto Project의 make 툴이라고 이해하면 되는데, 다른 용어는 어떤 의미 인지 모호할 수 있다. OpenEmbedded와 Yocto Project와의 관계는 어떤 것인지, Poky는 범위가 어떤 것인지 메뉴얼을 보아도 정확히 감을 잡기가 어렵다.
개념적으로 잘 정리된 관계는 Yocto Project Overview and Concepts Manual, 2.1 What is the Yocto Proejct?&amp;quot;에 있는 아래 그림이다.
Yocto Elements" Yocto Elements 우선은 이를 이해하기 위하여는 Yocto Project가 발전한 변천사를 보는 것이 좋다.</description></item><item><title>Orange Pi 보드용 이미지 수작업으로 만들기</title><link>https://blog.humminglab.io/posts/orange-pi-based-factory-image/</link><pubDate>Wed, 30 May 2018 10:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/orange-pi-based-factory-image/</guid><description>Orange Pi 는 Allwinner(SUNXI) 의 application chip으로 만들어진 single board computer이다. Raspberry Pi 와 비슷하다고 볼 수 있는데, 이것과 비교하여 주요 장단점은 다음과 같다.
장점 Cortex A8 single core부터 octa core 까지 라인업 Mali400 GPU 내장 무엇보다도 가격이 저렴. 아래에서 사용하는 Orange Pi R1의 경우 소비자가가 $9.99. 단점 CPU 사양이 제대로 공개가 안됨. 그나마 H3 정도까지는 인터넷 커뮤니티에 어느정도 공개 됨 발열이 심함. Orange Pi R1의 경우도 별도로 방열판을 붙어야 안정적임 이 문서에서는 Orange Pi R1을 제품에 적용하기 위하여 보드 이미지 설정을 하는 과정을 정리한 것이다.</description></item><item><title>WICED eventloop library</title><link>https://blog.humminglab.io/posts/wiced-event-loop/</link><pubDate>Tue, 17 Apr 2018 17:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/wiced-event-loop/</guid><description>WICED와 같은 임베디드 디바이스용 SDK는 FreeRTOS, ThreadX와 같은 RTOS의 multi tasking 기능을 이용하여 여러개의 task를 생성하여 주변기기를 제어하거나 네트워크로 데이타 송수신 한다. 일반적인 산업용 기기의 센서 동작은 realtime 요구 사항에 맞추어 task로 분리하여 작성하면 된다. 하지만 가정용 IoT 기기를 만들다 보면 이와 같은 multi task 방식 보다는 하나의 task에서 event driven 방식으로 구현을 하는 것이 편리할 때가 있다.
이 문서에서는 가정용 기기의 특징과 이를 task 방식으로 구현하였을 때의 단점을 설명하고, 구현한 event loop library를 설명한다.</description></item><item><title>Embedded IoT 플랫폼에서 Wi-Fi 지원</title><link>https://blog.humminglab.io/posts/wifi-for-iot-product/</link><pubDate>Tue, 17 Apr 2018 05:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/wifi-for-iot-product/</guid><description>Embedded 형태의 IoT의 센서 노드를 개발하기 위한 플랫폼(HW + SW SDK)은 다양해져서 잠깐만 인터넷 검색을 해보아도 여러 솔루션을 찾아 볼 수 있다. 특히 센서 노드의 특성 상 이들 SDK는 IEEE 802.15.4(Zigbee, Thread), IEEE 802.15.1(Bluetooth, BLE), IEEE 802.11(Wi-Fi)와 같은 wireless internet connectivity가 주요 기능으로 들어간다.
이 문서에서는 제품에 Wi-Fi 기능을 넣기 위하여 솔루션 선정 시 고려할 사항들을 정리한다.
Constrained Devices IoT 센서 기기와 같은 경우는 배터리로 구동하거나, 낮은 사양 등 일반 PC 나 android 기기에 비하여 저사양 기기라고 할 수 있다.</description></item><item><title>Python 비동기 프로그래밍 제대로 이해하기(2/2) - Asyncio, Coroutine</title><link>https://blog.humminglab.io/posts/python-coroutine-programming-2/</link><pubDate>Fri, 30 Mar 2018 17:00:00 +0900</pubDate><author><name>YSLee</name><uri>https://www.humminglab.io</uri><email>info@humminglab.io</email></author><guid>https://blog.humminglab.io/posts/python-coroutine-programming-2/</guid><description>이글은 Python 비동기 프로그래밍 제대로 이해하기(1/2) 에 이어서 작성한 글이다.
Asyncio Python 3.4 에서는 그동안 Twisted, Tornado와 같이 별도의 library로 제공되던 event loop 방식의 비동기 프로그래밍이 asyncio (PEP 3156 &amp;ndash; Asynchronous IO Support Rebooted: the &amp;ldquo;asyncio&amp;rdquo; Module) 표준 라이브러리로 새로 추가되었다.
각각의 event loop 구현이 비슷하지만 약간의 차이가 있어서 이들을 혼용하여 사용할 때 차이점을 이해하는데 부담이 있지만, 시간이 지나며 이들도 asyncio로 통합 지원하는 방향으로 되는 것 같다. 참고로 2018년 3월에 새로 릴리즈된 Tornado 5.</description></item></channel></rss>