<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title class=pjax-title>TLS/암호 알고리즘 쉽게 이해하기(9) - Digital Signature - All about IoT</title><meta name=Description content><meta property="og:title" content="TLS/암호 알고리즘 쉽게 이해하기(9) - Digital Signature"><meta property="og:description" content="DSA는 Digital Signature Algorothm 의 약자로, 미국 NIST 에서 제정한 디지털 서명 알고리즘이다.
이번 글에서는 이와 같은 디지털 서명에 관한 전반적인 사항을 다음과 같은 순서로 정리한다.
 RSA 서명 알고리즘 ElGamal 서명 알고리즘 DSA 서명 알고리즘 OpenSSL 을 이용한 동작 확인  RSA Signature RSA 서명 방식은 앞의 RSA 글에서 언급한 것과 같이 개인키로 문서의 Hash 값을 암호화 하는 것으로 RSA의 동작 원리를 알고 있으면 직관적이다. 관련 표준은 PKCS#1의 8장 을 보면 된다."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.humminglab.io/posts/tls-cryptography-9-dsa/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-12T09:00:00+09:00"><meta property="article:modified_time" content="2022-04-12T09:00:00+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="TLS/암호 알고리즘 쉽게 이해하기(9) - Digital Signature"><meta name=twitter:description content="DSA는 Digital Signature Algorothm 의 약자로, 미국 NIST 에서 제정한 디지털 서명 알고리즘이다.
이번 글에서는 이와 같은 디지털 서명에 관한 전반적인 사항을 다음과 같은 순서로 정리한다.
 RSA 서명 알고리즘 ElGamal 서명 알고리즘 DSA 서명 알고리즘 OpenSSL 을 이용한 동작 확인  RSA Signature RSA 서명 방식은 앞의 RSA 글에서 언급한 것과 같이 개인키로 문서의 Hash 값을 암호화 하는 것으로 RSA의 동작 원리를 알고 있으면 직관적이다. 관련 표준은 PKCS#1의 8장 을 보면 된다."><meta name=application-name content="All about IoT"><meta name=apple-mobile-web-app-title content="All about IoT"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://blog.humminglab.io/posts/tls-cryptography-9-dsa/><link rel=prev href=https://blog.humminglab.io/posts/tls-cryptography-8-rsa/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"TLS/암호 알고리즘 쉽게 이해하기(9) - Digital Signature","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.humminglab.io\/posts\/tls-cryptography-9-dsa\/"},"genre":"posts","keywords":"Cryptography, ElGamal, DSA, RSA","wordcount":1840,"url":"https:\/\/blog.humminglab.io\/posts\/tls-cryptography-9-dsa\/","datePublished":"2022-04-12T09:00:00+09:00","dateModified":"2022-04-12T09:00:00+09:00","publisher":{"@type":"Organization","name":"HummingLab"},"authors":[{"@type":"Person","name":"YSLee"}],"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e)}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(t){const e=document.getElementsByTagName("meta");for(let n=0;n<e.length;n++)if(e[n].getAttribute("name")===t)return e[n];return''}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?setTheme("dark"):setTheme("light")}else''==="light"||''==="dark"||''==="black"?(setTheme(''),saveTheme('')):(saveTheme("auto"),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?setTheme("dark"):setTheme("light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")]</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="All about IoT">All about IoT</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=https://www.humminglab.io/ rel="noopener noreffer" target=_blank>HummingLab </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="All about IoT">All about IoT</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=https://www.humminglab.io/ title rel="noopener noreffer" target=_blank>HummingLab</a><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class="toc-content always-active" id=toc-content-auto></div></div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">TLS/암호 알고리즘 쉽게 이해하기(9) - Digital Signature</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.humminglab.io/authors/yslee>YSLee</a></span>
</span>&nbsp;<span class=post-category>included in </span>&nbsp;<span class=post-category>category <a href=/categories/security/><i class="far fa-folder fa-fw"></i>Security</a></span>&nbsp;<span class=post-category>and</span>&nbsp;<span class=post-series>series <a href=/series/tls/%EC%95%94%ED%98%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/><i class="far fa-list-alt fa-fw"></i>TLS/암호 알고리즘 쉽게 이해하기</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-04-12>2022-04-12</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2022-04-12>2022-04-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1840 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;9 minutes&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#rsa-signature>RSA Signature</a></li><li><a href=#elgamal-signature>ElGamal Signature</a><ul><li><a href=#elgamal-encryption>ElGamal Encryption</a></li><li><a href=#elgamal-signature-1>ElGamal Signature</a></li><li><a href=#elgamal-활용>ElGamal 활용</a></li></ul></li><li><a href=#dsa-signature>DSA Signature</a></li><li><a href=#openssl>OpenSSL</a><ul><li><a href=#rsa-signature-1>RSA Signature</a></li><li><a href=#dsa-signature-1>DSA Signature</a></li></ul></li><li><a href=#마치며>마치며</a></li></ul></nav></div></div><div class=content id=content><p>DSA는 Digital Signature Algorothm 의 약자로, 미국 NIST 에서 제정한 디지털 서명 알고리즘이다.</p><p>이번 글에서는 이와 같은 디지털 서명에 관한 전반적인 사항을 다음과 같은 순서로 정리한다.</p><ul><li>RSA 서명 알고리즘</li><li>ElGamal 서명 알고리즘</li><li>DSA 서명 알고리즘</li><li>OpenSSL 을 이용한 동작 확인</li></ul><h2 id=rsa-signature>RSA Signature</h2><p>RSA 서명 방식은 앞의 <a href=https://blog.humminglab.io/posts/tls-cryptography-8-rsa/ rel>RSA</a> 글에서 언급한 것과 같이
개인키로 문서의 Hash 값을 암호화 하는 것으로 RSA의 동작 원리를 알고 있으면 직관적이다.
관련 표준은 <a href=https://tools.ietf.org/html/rfc8017 target=_blank rel="noopener noreffer">PKCS#1</a>의 8장 을 보면 된다.</p><p>서명 절차는 아래와 같다.</p><ul><li>Alice는 사전에 자신의 공개키를 배포한다.</li><li>문서를 아래와 같이 SHA-1 과 같은 hash 함수를 이용하여 줄이고, 이를 RSA 암호 블럭 크기에 맞추어 적절히 패딩을 추가</li><li>이를 자신의 RSA 개인키로 암호화 (서명)</li><li>문서와 서명을 같이 배포</li></ul><div class=mermaid id=id-1></div><p>문서와 서명을 받은 Bob은 다음과 같은 절차로 검증을 할 수 있다.</p><ul><li>서명 데이타를 Alice의 공개키로 복호화</li><li>패딩 값들이 적절한지 확인</li><li>본문의 Hash 결과와 위 복호화 한 결과가 일치하는지 확인</li></ul><div class=mermaid id=id-2></div><p>RSA 의 개인키가 없으면 이와 같은 암호화(서명)를 할 수 없다는 것을 이용하는 방식이다.</p><p><a href=https://blog.humminglab.io/posts/tls-cryptography-8-rsa/ rel>RSA</a> 에서 언급하였던 것과 같이 보통 RSA 공개키 값은 65537(0x10001) 과 같이 개인키에 비하여 상대적으로 짧은 값이다.
이는 더 자주 사용하는 검증을 위한 연산량이 서명을 위한 연산량보다 작다는 장점도 있다.</p><h2 id=elgamal-signature>ElGamal Signature</h2><p>ElGamal Algorithm은 RSA 처럼 <a href=https://blog.humminglab.io/posts/tls-cryptography-6-math/ rel>이산대수 문제</a>를 이용하는 방식이다.</p><p>ElGamal 방식도 RSA 처럼 암호화와 서명 두 가지 방식을 지원한다.
RSA의 경우 암호화나 서명이나 어떤 데이타를 어떤 키로 암호화 하는지만 다르지만, ElGamal 방식은 암호화와 서명 방법이 조금 다르다.</p><p>우선은 이를 이해하기 위하여 이산대수 문제를 간략히 다시 정리해 본다.</p><ul><li><p>소수 모듈러 연산은 사칙연산에 닫혀 있고, 교환법칙, 결합법칙도 성립한다.</p></li><li><p>페르마의 소정리에 의하여 소수 $p$ 보다 작고 0보다 큰 양수 $k$ 에 대해 다음 식이 항상 성립한다.</p><ul><li>$k^{p-1} \equiv 1 \pmod p$</li></ul></li><li><p>아래 처럼 $p$를 곱해서 지수만 보면 $(p-1)$의 모듈러 연산이 된다.</p><ul><li>$k^p \equiv k^1 \pmod p$</li><li>$p = 1 \pmod {p-1}$</li></ul></li><li><p>$(p-1)$ 과 서로소인 $s$ 를 임의로 선정하면, 확장 유클리드 호제법으로 모듈러 $(p-1)$ 에서 $s$의 곱하기 역원 $t$를 찾을 수 있다.</p></li></ul><p>위에서 찾은 $p$, $s$, $t$ 가 이산대수 암호화의 기본적인 요소로 사용된다.
조금 더 자세한 내용은 <a href=https://blog.humminglab.io/posts/tls-cryptography-6-math/ rel>이산대수 문제</a> 를 참고하면 된다.</p><h3 id=elgamal-encryption>ElGamal Encryption</h3><p>Bob은 다음과 같이 키를 만든다.</p><ul><li>큰 소수 $p$ 선정</li><li>$p$ 보다 작은 임의의 숫자 primitive root $\alpha$, 비밀키 $z$를 선정하여 다음과 같이 $\beta$ 를 계산</li><li>$\beta \equiv \alpha^z \pmod p$</li><li>$(p, \alpha, \beta)$는 공개키, $z$은 개인키로 공개키를 사전에 공유한다.</li></ul><p>Alice는 Bob의 공개키를 이용하여 평문 $m$을 다음과 같이 암호화 한다.</p><ul><li>$(p-1)$ 과 서로소인 임의의 랜덤 $k$를 선택</li><li>다음과 같은 $r, s$를 계산<ul><li>$r \equiv \alpha^k \pmod p$</li><li>$s \equiv m \beta^k \pmod p$</li></ul></li><li>$r, s$를 전송 ($k$는 비공개)</li></ul><p>$s$는 평문이 $\beta^k$가 곱해져 암호화된 값이고, $r$은 이를 풀기 위한 힌트라고 볼 수 있다.</p><p>Bob은 $\beta^k$의 모듈러 $p$에 대한 곱하기 역원만 구하면 된다.
Bob은 다음과 같이 연산을 하여 복호화 할 수 있다.</p><ul><li>$s$ 에 포함된
$\beta^k \pmod p$ 는 다음과 같이 변형하여 $r$ 로 부터 얻을 수 있다.<ul><li>$\beta^k \equiv (\alpha^z)^k \equiv (\alpha^k)^z \equiv r^z \pmod p$</li></ul></li><li>위의 값을 얻은 후 이를 확장 유클리드 호제법을 이용하여 모듈러 곱하기 역원 $\overline{\beta^k}$ 를 계산한다.</li><li>이를 $s$에 곱하여 원문을 얻는다.<ul><li>$s \overline{\beta^k} \equiv (m \beta^k) \overline{\beta^k} \equiv m \pmod p$</li></ul></li></ul><p>암호화를 하면 데이타량이 두배가 되지만, 동일한 원문을 동일한 키로 암호화를 하는 경우에도 랜덤 $k$ 로 인하여 암호화 결과가 매번 달라지는 장점이 있다.</p><p>다른 모든 암호 알고리즘과 마찬가지로 이 random $k$ 값을 재사용하면 암호가 쉽게 깨지는 문제가 있어 주의하여야 한다.</p><h3 id=elgamal-signature-1>ElGamal Signature</h3><p>서명도 암호화와 비슷하지만 약간 다르게 적용된다.</p><p>서명을 할 Alice는 암호화 방식과 동일하게 다음과 같은 키를 만든다.</p><ul><li>큰 소수 $p$ 선정</li><li>$p$ 보다 작은 임의의 숫자 primitive root $\alpha$, 비밀키 $z$를 선정하여 다음과 같이 $\beta$ 를 계산</li><li>$\beta \equiv \alpha^z \pmod p$</li><li>$(p, \alpha, \beta)$는 공개키, $z$은 개인키로 공개키를 사전에 공유한다.</li></ul><p>Alice는 자신의 개인키로 원문 $m$을 다음과 같이 서명한다.</p><ul><li>$(p-1)$ 과 서로소인 임의의 랜덤 $k$를 선택</li><li>다음과 같은 $r, s$를 계산. $\overline{k}$는 $k$의 모듈러 $(p-1)$의 곱하기 역원이다.<ul><li>$r \equiv \alpha^k \pmod p$</li><li>$s \equiv \overline{k} (m - zr) \pmod {p-1}$</li></ul></li><li>원문 $m$과 서명 $(r, s)$를 전송</li></ul><p>Bob은 다음과 같이 두 연산을 수행하여 비교한다.</p><ul><li>$v_1 \equiv \beta^r r^s \pmod p$</li><li>$v_2 \equiv \alpha^m \pmod p$</li><li>위 두 값 $v_1 \equiv v_2$ 이면 검증 OK</li></ul><p>알고리즘의 검증은 조금 복잡한데 다음과 같이 확인할 수 있다.</p><ul><li>우선 $s$에 $k$를 곱하여 제거한다.<ul><li>$sk \equiv \overline{k} (m - zr)k \equiv (m-zr) \pmod {p-1}$</li></ul></li><li>이를 $m$ 으로 다시 정리해 보면 다음과 같다.<ul><li>$m \equiv sk + zr \pmod {p-1}$</li></ul></li><li>위 $v_2$의 $m$을 위의 값으로 치환하면 다음과 같다.<ul><li>$v_2 \equiv \alpha^m \equiv \alpha^{sk+zr} \equiv \alpha^{sk} \cdot \alpha^{zr} \equiv (\alpha^k)^s \cdot (\alpha^z)^r \equiv r^s\beta^r \equiv v_1 \pmod p$</li></ul></li></ul><p>위와 같이 지수 $m$을 $sk + zr \pmod {p-1}$ 로 대체할 수 있는 것은 페르마 소정리에 의하여 지수만 보면 $(p-1)$ 모듈러 연산 형태가 되기 때문이다.</p><h3 id=elgamal-활용>ElGamal 활용</h3><p>TLS에서 ElGamal 방식은 직접적으로는 사용하지 않는다.</p><p>지금은 RSA도 특허가 만료되어 큰 장점은 아니지만 초기에 ElGamal 방식은 특허가 없어서 오픈소스 암호화 알고리즘에서 많이 사용하였다.
<a href=https://en.wikipedia.org/wiki/Pretty_Good_Privacy target=_blank rel="noopener noreffer">PGP(Pretty Good Privacy)</a> 도 이를 기반으로 공개키를 사용한다.</p><p>ElGamal 서명은 직접적으로 사용하지는 않으나 상용을 포함한 많은 서명 알고리즘이 이를 기반으로 하고 있다. 다음에 설명할 DSA, ECDSA가 이를 기반으로 하는 서명 알고리즘이다.</p><h2 id=dsa-signature>DSA Signature</h2><p>DSA를 이해하기 위하여는 ElGamal 서명을 먼저 알고, 이와 어떻게 다른지를 이해하는 것이 좋다.</p><p>DSA는 ElGamal의 취약점을 개선한 것으로 다음과 같은 장점이 있다.</p><ul><li>ElGamal에 비하여 연산이 빠르다.</li><li>DSA는 두개의 서로 다른 이산대수 공격을 공격을 하여야만 풀 수 있다.</li><li>서명 크기가 작다.</li></ul><p>서명은 다음과 같은 절차로 수행한다.</p><p>서명을 할 Alice는 다음과 같은 방식으로 키를 만든다.</p><ul><li>두 소수 $p$ 와 $q$를 찾는다.<ul><li>$p$는 1024bit 길이의 임의의 소수를 선정한다.</li><li>$q$는 160bit 길이의 소수이면서, $(p-1)$ 의 약수인 임의의 수를 선정한다. (1024bit, 160bit는 임의로 정한 길이로 암호화 강도에 따라 조정이 된다)</li><li>소인수 분해가 어려우므로 실제로는 $q$를 먼저 선정하고, 이에 맞는 $p$를 찾는다.</li></ul></li><li>Primitive root $g$를 임의로 선정하여 다음과 같이 $\alpha$를 계산한다.<ul><li>$\alpha \equiv g^{(p-1)/q} \pmod p$</li><li>위 수식의 의미는 페르마 소정리($g^{p-1}\equiv 1 \pmod p$)에 의하여 다음과 같은 의미가 된다.<ul><li>$\alpha ^q \equiv 1 \pmod p$</li></ul></li></ul></li><li>비밀키 $z$ 를 선정하여 다음과 같이 $\beta$ 를 구한다.<ul><li>$\beta \equiv \alpha ^ z \pmod p$</li></ul></li><li>위에서 얻은 $(p, q, \alpha, \beta)$ 는 공개키가 되고, $z$ 은 비밀키가 된다.</li><li>위 식을 보면 전체는 모듈러 $p$ 연산이지만, 지수부는 모듈러 $q$ 연산이 된다.</li></ul><p>DSA에서는 서명 시 본문을 그대로 사용하지 않고, SHA 같은 hash 함수를 이용한 축약된 hash 값을 서명한다($q$ 값은 이 hash 크기 보다는 큰 수가 되어야 한다).</p><p>Alice는 다음과 같이 서명한다.</p><ul><li>$(q-1)$보다 작은 임의의 랜덤값 $k$를 선정한다.</li><li>본문 $m$의 hash 값 $x$를 얻는다.</li><li>다음과 같이 $r, s$ 를 구한다. ($r$은 $p, q$ 각각의 모듈로 연산을 함)<ul><li>$r \equiv (\alpha^k \pmod p) \pmod q$</li><li>$s \equiv \overline{k} (x + zr) \pmod q$</li></ul></li><li>서명으로 $x, (r,s)$를 본문 $m$과 같이 전달한다.</li></ul><p>Bob은 다음과 같이 서명을 검증한다.</p><ul><li>다음 세 연산 수행<ul><li>$u_1 \equiv \overline{s}x \pmod q$</li><li>$u_2 \equiv \overline{s}r \pmod q$</li><li>$v \equiv (\alpha^{u_1} \beta^{u_2} \mod p) \pmod q$</li></ul></li><li>$v = r$ 이면 검증 OK</li></ul><p>검증은 다음과 같이 할 수 있다.</p><ul><li>우선 $s$에 $k$를 곱하여 $\overline{k}$를 제거한다.<ul><li>$ks \equiv x + zr \pmod q$</li></ul></li><li>이를 다시 $s$의 역원 $\overline{s}$를 곱하여 $s$를 제거한다.<ul><li>$k \equiv ks\overline{s} \equiv x \overline{s} + zr \overline{s} \pmod q$</li></ul></li><li>이식을 위에서 구한 $u_1$ 과 $u_2$로 치환한다.<ul><li>$k \equiv u_1 + z u_2 \pmod q$</li></ul></li><li>$r$ 식의 지수부는 $q$의 모듈러 연산이므로, 위의 $k$로 치환 할 수 있다.
$$
\begin{align*}
r &\equiv (a^k \bmod p) \bmod q \\
&\equiv (\alpha^{u_1 + zu_2} \bmod p) \bmod q \\
&\equiv (\alpha^{u_1} (\alpha^z)^{u_2} \bmod p) \bmod q \\
&\equiv (\alpha^{u_1}\beta^{u_2} \bmod p) \bmod q
\end{align*}
$$</li><li>결과로 $r \equiv v$ 가 된다.</li></ul><p>DSA는 암호화에 사용시 키 길이에 따라 다음과 같은 $p$ 와 $q$ 를 사용한다. 이때의 서명 길이는 $r,s$ 로 $q$ 길이의 2배가 된다.</p><table><thead><tr><th>p</th><th>q</th><th>서명길이</th><th>노트</th></tr></thead><tbody><tr><td>1024</td><td>160</td><td>320</td><td>보안상 더이상 사용치 않음</td></tr><tr><td>2048</td><td>256</td><td>512</td><td>초기에는 q로 224bit를 사용하나, 지금은 256bit를 이용</td></tr><tr><td>3072</td><td>256</td><td>512</td><td></td></tr></tbody></table><h2 id=openssl>OpenSSL</h2><p>위의 알고리즘을 OpenSSL 을 이용하여 확인을 해보자.</p><h3 id=rsa-signature-1>RSA Signature</h3><p>우선 다음과 같이 RSA private, public key를 생성한다.
키 생성에 대한 설명은 이전 글 <a href=https://blog.humminglab.io/posts/tls-cryptography-8-rsa/ rel>RSA</a>를 참조하면 된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl genrsa -out private.pem <span class=m>2048</span>
</span></span><span class=line><span class=cl>$ openssl rsa -in private.pem -out public.pem -pubout
</span></span></code></pre></td></tr></table></div></div><p>서명할 임의의 데이터를 생성한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=m>1234567890</span> &gt; mydata.txt
</span></span></code></pre></td></tr></table></div></div><p>openssl dgst 명령을 이용하여 다음과 같이 서명을 하면 서명파일 sha1.sign 이 생성된다.</p><ul><li>Message Digest Algorithm: SHA-1</li><li>Padding Scheme: PKCS#1 v1.5</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl dgst -sha1 -sign private.pem -out sha1.sign mydata.txt
</span></span></code></pre></td></tr></table></div></div><p>서명 검증은 다음과 같이 한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl dgst -sha1 -verify public.pem -signature sha1.sign mydata.txt
</span></span><span class=line><span class=cl>Verified OK
</span></span></code></pre></td></tr></table></div></div><p>서명 전의 원문 파일은 <a href=https://datatracker.ietf.org/doc/html/rfc8017#section-8.2 target=_blank rel="noopener noreffer">PKCS#1 v1.5 padding</a> 형식으로 다음과 같은 구조를 가진다.</p><ul><li>PKCS#1v1.5 padding scheme 구성: 00||01||PS||00||T||H</li><li><strong>H</strong>: SHA-1 으로 계산된 hash 값</li><li><strong>T</strong>: ASN.1 로 encoding된 SAH-1 magic bytes</li><li><strong>PS</strong>: 암호 블럭의 나머지 공간을 0xff 로 패딩. RSA-2048 의 경우 256-38=218바이트</li></ul><figure><img src=rsa-pkcs1-1.5-padding.png alt="PKCS#1 v1.5 padding" width=600px height=auto><figcaption><p>PKCS#1 v1.5 padding</p></figcaption></figure><p>이번에는 openssl rsautl 을 이용하여 풀어보자.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl rsautl -verify -inkey public.pem -in sha1.sign -pubin <span class=p>|</span> hexdump -C
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>00000000</span>  <span class=m>30</span> <span class=m>21</span> <span class=m>30</span> <span class=m>09</span> <span class=m>06</span> <span class=m>05</span> 2b 0e  <span class=m>03</span> <span class=m>02</span> 1a <span class=m>05</span> <span class=m>00</span> <span class=m>04</span> <span class=m>14</span> <span class=m>12</span>
</span></span><span class=line><span class=cl><span class=m>00000010</span>  <span class=m>03</span> 9d 6d d9 a7 e2 <span class=m>76</span> <span class=m>22</span>  <span class=m>30</span> 1e <span class=m>93</span> 5b 6e ef c7 <span class=m>88</span>
</span></span><span class=line><span class=cl><span class=m>00000020</span>  <span class=m>46</span> <span class=m>80</span> 2e
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ openssl sha1 mydata.txt
</span></span><span class=line><span class=cl>SHA1<span class=o>(</span>mydata.txt<span class=o>)=</span> 12039d6dd9a7e27622301e935b6eefc78846802e
</span></span></code></pre></td></tr></table></div></div><p><code>-verify</code> 명령은 실제로 검증까지는 하지 않고, 공개키로 복호화하여 padding을 제거한 데이타를 출력한다.</p><p>sha1의 결과값이 뒤에 들어가 있는 것을 확인할 수 있다.</p><p>앞에 들어간 3021300906052b0e03021a05000414 magic byte는 ASN.1 이라는 형식으로 인코딩 된 것으로 <code>-asn1parse</code> 옵션을 추가하여 확인할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl rsautl -verify -inkey public.pem -in sha1.sign -pubin -asn1parse
</span></span><span class=line><span class=cl>    0:d<span class=o>=</span><span class=m>0</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>  <span class=m>33</span> cons: SEQUENCE
</span></span><span class=line><span class=cl>    2:d<span class=o>=</span><span class=m>1</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>   <span class=m>9</span> cons:  SEQUENCE
</span></span><span class=line><span class=cl>    4:d<span class=o>=</span><span class=m>2</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>   <span class=m>5</span> prim:   OBJECT            :sha1
</span></span><span class=line><span class=cl>   11:d<span class=o>=</span><span class=m>2</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>   <span class=m>0</span> prim:   NULL
</span></span><span class=line><span class=cl>   13:d<span class=o>=</span><span class=m>1</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>  <span class=m>20</span> prim:  OCTET STRING
</span></span><span class=line><span class=cl>      <span class=m>0000</span> - <span class=m>12</span> <span class=m>03</span> 9d 6d d9 a7 e2 76-22 <span class=m>30</span> 1e <span class=m>93</span> 5b 6e ef c7   ...m...v<span class=s2>&#34;0..[n..
</span></span></span><span class=line><span class=cl><span class=s2>      0010 - 88 46 80 2e                                       .F..
</span></span></span></code></pre></td></tr></table></div></div><h3 id=dsa-signature-1>DSA Signature</h3><p>우선 다음과 같이 2048bit DSA 개인키와 공개키를 만든다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl dsaparam -out dsaparam.pem <span class=m>2048</span>
</span></span><span class=line><span class=cl>$ openssl gendsa -out dsa_priv.pem dsaparam.pem
</span></span><span class=line><span class=cl>$ openssl dsa -in dsa_priv.pem -pubout -out dsa_pub.pem
</span></span></code></pre></td></tr></table></div></div><p>dsa_priv.pem 의 내용을 보면 다음과 같이 구성된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl dsa -in dsa_priv.pem -text -noout
</span></span><span class=line><span class=cl><span class=nb>read</span> DSA key
</span></span><span class=line><span class=cl>Private-Key: <span class=o>(</span><span class=m>2048</span> bit<span class=o>)</span>
</span></span><span class=line><span class=cl>priv:
</span></span><span class=line><span class=cl>    ... <span class=o>(</span><span class=m>256</span> bit<span class=o>)</span>
</span></span><span class=line><span class=cl>pub:
</span></span><span class=line><span class=cl>    ... <span class=o>(</span><span class=m>2048</span> bit<span class=o>)</span>
</span></span><span class=line><span class=cl>P:
</span></span><span class=line><span class=cl>    ... <span class=o>(</span><span class=m>2048</span> bit<span class=o>)</span>
</span></span><span class=line><span class=cl>Q:
</span></span><span class=line><span class=cl>    ... <span class=o>(</span><span class=m>256</span> bit<span class=o>)</span>
</span></span><span class=line><span class=cl>G:
</span></span><span class=line><span class=cl>    ... <span class=o>(</span><span class=m>2048</span> bit<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>위의 설명과 비교하면 다음과 같이 된다.</p><ul><li>$z$; priv</li><li>$p$: P</li><li>$q$: Q</li><li>$\alpha$: G</li><li>$\beta$: pub</li></ul><p>서명은 다음과 같이하여 생성할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl dgst -sha1 -sign dsa_priv.pem -out mydata.txt.sig mydata.txt
</span></span><span class=line><span class=cl>$ ls -l mydata.txt.sig
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> yslee  staff  <span class=m>70</span>  <span class=m>4</span> <span class=m>12</span> 11:18 mydata.txt.sig
</span></span></code></pre></td></tr></table></div></div><p>Q가 256bit(32bytes)로 서명은 2배 길이인 64bytes이어야 하는데, 파일 크기가 70bytes 인 것은 서명이 ASN.1 DER encoding 되어 있기 때문이다.</p><p>다음과 같이 256bit의 $r$ 과 $s$ 를 확인할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl asn1parse -in mydata.txt.sig -inform DER
</span></span><span class=line><span class=cl>    0:d<span class=o>=</span><span class=m>0</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>  <span class=m>68</span> cons: SEQUENCE
</span></span><span class=line><span class=cl>    2:d<span class=o>=</span><span class=m>1</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>  <span class=m>32</span> prim: INTEGER           :6955D869E8F438018D9D0615D40A280551B4F0654B967BBA262C4FFFF1D32C40
</span></span><span class=line><span class=cl>   36:d<span class=o>=</span><span class=m>1</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>  <span class=m>32</span> prim: INTEGER           :7E4FDBE5484759B4725DF862ECCB5E6D8078766C9F8AB2006B3D9C00B752D749
</span></span></code></pre></td></tr></table></div></div><p>서명 검증은 다음과 같이 할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl dgst -sha1 -verify dsa_pub.pem -signature mydata.txt.sig mydata.txt
</span></span><span class=line><span class=cl>Verified OK
</span></span></code></pre></td></tr></table></div></div><h2 id=마치며>마치며</h2><p>서명과 관련된 사항을 전반적으로 정리 하다보니 내용이 길어진 것 같다.
이산대수로 정리한 부분만 제대로 이해하면 ElGamal 이나 DSA 알고리즘에 대해서는 이해할 수 있을 것이다.</p><p>서명과 관련된 표준은 미국 NIST 에서 정의한 <a href=https://csrc.nist.gov/publications/detail/fips/186/4/final target=_blank rel="noopener noreffer">FIPS 186-4, Digital Signature Standard (DSS)</a> 를 참고할 수 있다.
이 문서에는 DSA, RSA 서명, ECDSA 에 대해서 정의되어 있다.</p><p>ECDSA는 DSA 의 이산대수 문제를 Elliptic Curve (EC) 로 대체하는 알고리즘으로 다음 기회에 타원곡선 알고리즘에서 설명할 예정이다.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-04-12</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/cryptography-elgamal-dsa-rsa/>Cryptography, ElGamal, DSA, RSA</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/tls-cryptography-8-rsa/ class=prev rel=prev title="TLS/암호 알고리즘 쉽게 이해하기(8) - RSA"><i class="fas fa-angle-left fa-fw"></i>TLS/암호 알고리즘 쉽게 이해하기(8) - RSA</a></div></div><div id=comments><div id=giscus></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/>giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://www.humminglab.io target=_blank rel="noopener noreferrer">HummingLab</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-83257319-3",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-83257319-3" async></script></div><div class=pjax-assets><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript src=/lib/mermaid/mermaid.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{giscus:{darkTheme:"dark",dataCategory:"Announcements",dataCategoryId:"DIC_kwDOGdk00s4CAGXN",dataEmitMetadata:"0",dataMapping:"pathname",dataReactionsEnabled:"1",dataRepo:"humminglab/blog.humminglab.io",dataRepoId:"R_kgDOGdk00g",lightTheme:"light"}},data:{"id-1":"graph LR;\n\nsubgraph RSA 서명\nA1([문서]) --\u003e B1[Hash] --\u003e B2([Hash값+Padding]) --\u003e C1[RSA 개인키 암호] --\u003e D1([서명])\nend\nstyle B1 fill:#FFF9C4\nstyle C1 fill:#FFF9C4","id-2":"graph LR;\n\nsubgraph RSA 서명\nD1([서명]) --\u003e C1[RSA 공개키 복호] --\u003e B1[Hash값 + padding]\nend\nstyle C1 fill:#FFF9C4"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},mermaid:!0}</script><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/katex.min.css><noscript><link rel=stylesheet href=/lib/katex/katex.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/mermaid/mermaid.min.css><noscript><link rel=stylesheet href=/lib/mermaid/mermaid.min.css></noscript></div></body></html>