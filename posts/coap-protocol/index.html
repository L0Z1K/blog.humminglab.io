<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<title class=pjax-title>CoAP Protocol - All about IoT</title><meta name=Description content><meta property="og:title" content="CoAP Protocol">
<meta property="og:description" content="2015년 Eclipse IOT survey 결과를 보면 가장 많이 사용하는 메시징 프로토콜은 HTTP, MQTT, CoAP 이다.
HTTP가 주요 프로토콜인 것은 두말할 필요도 없고, MQTT도 IBM에서 1999년에 개발하여 2010년에 무료로 오픈하여 나이로는 15년 이상된 것으로 Facebook Messenger 에서도 사용하는 등 다양한 곳에서 사용 중 이다. CoAP의 경우 2010년에 첫 draft가 나온 것으로 다른 프로토콜에 비하면 신생 프로토콜이라고 볼 수 있으나 점차로 사용하는 곳이 많아지는 것으로 보인다. 일 예로 작은 메모리를 가진 IOT open OS platform 인 mbed, zephyr 에서도 CoAP을 주 통신 프로토콜로 지원하고 있고, WICED 에서도 CoAP 제공하고 있다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.humminglab.io/posts/coap-protocol/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2016-12-14T20:26:00+09:00">
<meta property="article:modified_time" content="2016-12-14T20:26:00+09:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="CoAP Protocol">
<meta name=twitter:description content="2015년 Eclipse IOT survey 결과를 보면 가장 많이 사용하는 메시징 프로토콜은 HTTP, MQTT, CoAP 이다.
HTTP가 주요 프로토콜인 것은 두말할 필요도 없고, MQTT도 IBM에서 1999년에 개발하여 2010년에 무료로 오픈하여 나이로는 15년 이상된 것으로 Facebook Messenger 에서도 사용하는 등 다양한 곳에서 사용 중 이다. CoAP의 경우 2010년에 첫 draft가 나온 것으로 다른 프로토콜에 비하면 신생 프로토콜이라고 볼 수 있으나 점차로 사용하는 곳이 많아지는 것으로 보인다. 일 예로 작은 메모리를 가진 IOT open OS platform 인 mbed, zephyr 에서도 CoAP을 주 통신 프로토콜로 지원하고 있고, WICED 에서도 CoAP 제공하고 있다.">
<meta name=application-name content="All about IoT">
<meta name=apple-mobile-web-app-title content="All about IoT">
<meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://blog.humminglab.io/posts/coap-protocol/><link rel=prev href=https://blog.humminglab.io/posts/mqtt-protocol/><link rel=next href=https://blog.humminglab.io/posts/how-to-make-sdcard-disk-image/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/fontawesome-free/all.min.css>
<noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/animate/animate.min.css>
<noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"CoAP Protocol","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.humminglab.io\/posts\/coap-protocol\/"},"genre":"posts","keywords":"CoAP","wordcount":1377,"url":"https:\/\/blog.humminglab.io\/posts\/coap-protocol\/","datePublished":"2016-12-14T20:26:00+09:00","dateModified":"2016-12-14T20:26:00+09:00","publisher":{"@type":"Organization","name":"HummingLab"},"authors":[{"@type":"Person","name":"YSLee"}],"description":""}</script></head>
<body header-desktop header-mobile><script type=text/javascript>function setTheme(a){document.body.setAttribute('theme',a)}function saveTheme(a){window.localStorage&&localStorage.setItem('theme',a)}function getMeta(b){const a=document.getElementsByTagName('meta');for(let c=0;c<a.length;c++)if(a[c].getAttribute('name')===b)return a[c];return''}if(window.localStorage&&localStorage.getItem('theme')){let a=localStorage.getItem('theme');a==='light'||a==='dark'||a==='black'?setTheme(a):window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light')}else''==='light'||''==='dark'||''==='black'?(setTheme(''),saveTheme('')):(saveTheme('auto'),window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light'));let metaColors={light:'#f8f8f8',dark:'#252627',black:'#000000'};getMeta('theme-color').content=metaColors[document.body.getAttribute('theme')]</script>
<div id=back-to-top></div>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="All about IoT">All about IoT</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> Posts </a><a class=menu-item href=/tags/> Tags </a><a class=menu-item href=/categories/> Categories </a><a class=menu-item href=https://www.humminglab.io/ rel="noopener noreffer" target=_blank> HummingLab </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="All about IoT">All about IoT</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=https://www.humminglab.io/ title rel="noopener noreffer" target=_blank>HummingLab</a><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>Contents</h2>
<div class="toc-content always-active" id=toc-content-auto></div>
</div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">CoAP Protocol</h1><div class=post-meta>
<div class=post-meta-line>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.humminglab.io/authors/yslee>YSLee</a></span>
</span>&nbsp;<span class=post-category>included in </span>&nbsp;<span class=post-category>category <a href=/categories/iot/><i class="far fa-folder fa-fw"></i>IoT</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2016-12-14>2016-12-14</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2016-12-14>2016-12-14</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1377 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;7 minutes&nbsp;</div>
</div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#개요>개요</a></li>
<li><a href=#프로토콜>프로토콜</a>
<ul>
<li><a href=#네트워크-구성>네트워크 구성</a></li>
<li><a href=#헤더-구조>헤더 구조</a></li>
<li><a href=#메시지-전송>메시지 전송</a></li>
<li><a href=#cache--proxy>Cache & Proxy</a></li>
<li><a href=#observation>Observation</a></li>
</ul>
</li>
<li><a href=#마치며>마치며</a></li>
</ul>
</nav></div>
</div><div class=content id=content><p><a href=http://www.slideshare.net/IanSkerrett/iot-developer-survey-2015/18 target=_blank rel="noopener noreffer">2015년 Eclipse IOT survey 결과</a>를 보면 가장 많이 사용하는 메시징 프로토콜은 HTTP, <a href=https://blog.humminglab.io/posts/mqtt-protocol/ rel>MQTT</a>, CoAP 이다.</p>
<p>HTTP가 주요 프로토콜인 것은 두말할 필요도 없고, MQTT도 IBM에서 1999년에 개발하여 2010년에 무료로 오픈하여 나이로는 15년 이상된 것으로 <a href=https://en.wikipedia.org/wiki/Facebook_Messenger target=_blank rel="noopener noreffer">Facebook Messenger</a> 에서도 사용하는 등 다양한 곳에서 사용 중 이다.
CoAP의 경우 <a href=https://datatracker.ietf.org/doc/draft-ietf-core-coap/history/ target=_blank rel="noopener noreffer">2010년에 첫 draft</a>가 나온 것으로 다른 프로토콜에 비하면 신생 프로토콜이라고 볼 수 있으나 점차로 사용하는 곳이 많아지는 것으로 보인다. 일 예로 작은 메모리를 가진 IOT open OS platform 인 <a href=https://www.mbed.com/en/platform/mbed-client/ target=_blank rel="noopener noreffer">mbed</a>, <a href=https://www.zephyrproject.org/doc/subsystems/networking/networking.html target=_blank rel="noopener noreffer">zephyr</a> 에서도 CoAP을 주 통신 프로토콜로 지원하고 있고, <a href=http://www.cypress.com/internet-things-iot target=_blank rel="noopener noreffer">WICED</a> 에서도 CoAP 제공하고 있다.</p>
<p>여기에서는 CoAP의 기본적인 특징과 프로토콜의 개요를 정리해 보기로 한다.</p>
<h2 id=개요>개요</h2>
<p>CoAP 은 Constrained Application Protocol 의 약자로 RFC 7252 로 표준으로 등록되었다.
표준 이름에서도 알 수 있듯이 작은 센서 장치 등과 같이 CPU, 메모리, 통신 bandwidth 등이 제한된(constrained) 기기를 위한 application protocol 이다.</p>
<p>CoAP의 주요 목표는 아래와 같다고 할 수 있다.</p>
<ul>
<li>IP 기반, HTTP RESTful 개념을 적용</li>
<li>작은 메모리를 위하여 최대한 단순화 및 낮은 전송 대역을 위한 데이타 최소화</li>
</ul>
<p>즉, CoAP는 아래와 같은 기기를 위하여 만들어진 프로토콜이다.</p>
<ul>
<li>8bit 프로세서와 같은 저사양 센서 모듈에서도 구현 가능한 사양</li>
<li>802.15.4 기반의 무선 프로토콜(<a href=http://threadgroup.org/ target=_blank rel="noopener noreffer">thread</a>, <a href=http://www.zigbee.org/ target=_blank rel="noopener noreffer">zigbee</a>) 대응 (손실, 작은 패킷 크기)</li>
<li>IPv6 기반 (<a href=https://tools.ietf.org/html/rfc4944 target=_blank rel="noopener noreffer">6LoWPAN</a>)</li>
<li>쉽게 web(HTTP)에 연동하기 위한 경량화된 RESTful</li>
<li>CoAP-HTTP gateway에서도 stateless 로도 쉽게 HTTP로 변환하여 전달 가능</li>
</ul>
<p><a href=https://blog.humminglab.io/posts/mqtt-protocol/ rel>MQTT</a>와 비교해보면 아래와 같다.</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>CoAP</th>
<th>MQTT</th>
</tr>
</thead>
<tbody>
<tr>
<td>Communication Model</td>
<td>Request-Response, Publish-Subscribe</td>
<td>Publish-Subscribe</td>
</tr>
<tr>
<td>RESTful</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Transport Layer Protocol</td>
<td>UDP (TCP도 가능은 함)</td>
<td>TCP (MQTT-SN으로 UDP 대응)</td>
</tr>
<tr>
<td>Security</td>
<td>DTLS</td>
<td>SSL/TLS</td>
</tr>
<tr>
<td>Header</td>
<td>4 Bytes</td>
<td>2 Bytes</td>
</tr>
<tr>
<td>Encoding</td>
<td>Binary</td>
<td>Binary</td>
</tr>
<tr>
<td>메시지 종류</td>
<td>4</td>
<td>16</td>
</tr>
<tr>
<td>QoS</td>
<td>Yes (Confirmable / Non confirmable message)</td>
<td>Yes (3 levels)</td>
</tr>
<tr>
<td>Dynamic Discovery</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Messaging</td>
<td>Asynchronous & Synchronous</td>
<td>Asynchronous</td>
</tr>
</tbody>
</table>
<p>MQTT는 쉽게 말하면 채팅 개념을 이용하여 Machine-to-Machine 통신을 하는 것이다. 채팅 특성상 1:N 도 가능하고 이런 경우 동기 통신(명령에 대한 응답을 바로 받기) 자체는 불가능하므로 비동기 통신 기반의 메시지 큐 프로토콜 이라고 볼 수 있다. 채팅 서버 처럼 메시지를 중계할 서버(MQTT broker)가 필요하고, 이 서버와 상시 연결이 필요하고, 받고 싶은 메시지(채팅방 개념)를 정의할 subscribe 메시지도 필요하고, 비동기 방식의 특성을 감안하여 전달되는 메시지가 최소한 다음 노드 (MQTT broker)까지는 전달 되었는지를 확인하기 위한 QoS를 제공한다. 이로 인하여 메시지 종류도 16개 정도 된다.</p>
<p>반면에 CoAP는 한마디로 말해서 HTTP를 사용하면 좋겠는데, 리소스 제한상 사용 못하는 제한된 WPAN(Wireless Personal Area Network) 기기를 위한 lightweight 버전이라고 볼 수 있다. Payload 최대 크기가 127 바이트인 802.15.4 를 고려하여 헤더 필드 등 최대한 줄일 수 있는 만큼 줄이고, binary로 인코딩하고, 단순한 UDP를 사용하고, 암호화는 <a href=https://tools.ietf.org/html/rfc6347 target=_blank rel="noopener noreffer">RFC 6347 DTLS</a> 를 이용하여 datagram 단위로 하고, multicasting을 이용하여 discovery 기능을 제공하고, Request-Response 의 polling 방식 이외에 Publish-Subscribe event 방식을 추가한 것이라고 볼 수 있다. 이를 public network에서 운영하는 것도 가능하지만, 이 보다는 WPAN 에게 연결된 gateway까지만 이를 사용하고, 상위 단은 HTTP 등으로 변환하여 기존 웹 프레임웍을 활용하기 위한 것이라고 할 수 있다.</p>
<p>두 프로토콜의 근본이 다르기 때문에 어떤 용도로 사용하느냐에 따라서 각각의 기능이 장점이 될 수도 있고, 단점이 될 수도 있을 것이다.
어느 정도 명확한 구분점은 단말 기기가 802.3, 802.11 기반의 LAN protocol 을 지원하는지, 802.15.4 기반의 PAN protocol 을 지원하는지 일 것이다. 기존에 다른 기기를 위한 웹 플랫폼이 구축되어 있거나, PAN 기반의 장치를 접목한다면 CoAP 이 적절할 수 있고, LAN 기반의 기기를 접목한다면 MQTT 를 이용하는 것이 전체 구성이 단순해질 수 있을 것이다.</p>
<h2 id=프로토콜>프로토콜</h2>
<h3 id=네트워크-구성>네트워크 구성</h3>
<p>CoAP은 아래 그림과 같은 활용을 염두에 두고 설계되었다고 할 수 있다.</p>
<p><img class=lazyload data-src=coap.png data-srcset="/posts/coap-protocol/coap.png, coap.png 1.5x, /posts/coap-protocol/coap.png 2x" data-sizes=auto alt=/posts/coap-protocol/coap.png title=CoAP></p>
<p>개념적으로 HTTP와 비교해보면 아래와 같은 layer 구조를 가진다.</p>
<p><img class=lazyload data-src=coap-diagram.png data-srcset="/posts/coap-protocol/coap-diagram.png, coap-diagram.png 1.5x, /posts/coap-protocol/coap-diagram.png 2x" data-sizes=auto alt=/posts/coap-protocol/coap-diagram.png title="CoAP Layer"></p>
<h3 id=헤더-구조>헤더 구조</h3>
<p>CoAP의 Header는 아래와 같이 고정 4Bytes header와 가변의 optional 필드로 구성된다.</p>
<p><img class=lazyload data-src=coap-header.png data-srcset="/posts/coap-protocol/coap-header.png, coap-header.png 1.5x, /posts/coap-protocol/coap-header.png 2x" data-sizes=auto alt=/posts/coap-protocol/coap-header.png title="CoAP Header"></p>
<p>각각의 필드 설명은 다음과 같다.</p>
<ul>
<li>Version(VER): 2bits. RFC 7252 CoAP 버전은 1로 고정</li>
<li>Type(T): 2bits. 메시지 종류 구분. CoAp는 총 4종류의 메시지가 있다.
<ul>
<li>Confirmable (0), Non-confirmable (1), Acknowledgement (2), Reset (3) Reset (3)</li>
</ul>
</li>
<li>Token Length(TKL): 4bits. Token 필드의 길이를 0~8까지로 Token 필드가 있는 경우 해당 크기 표시.</li>
<li>Code: 8bits. 3bits.5bits로 나누어서 보면 HTTP의 response code와 유사한 형태가 된다. 예를 들어 401 이 HTTP 에서 ‘Unauthorized’ 인 것처럼 4.01 (이진수로 100.00001b) 은 ‘Unauthorized’이다. 앞의 class 부분만 보면 indicate a request (0), success response (2), client error response (4), server error response (5) 로 나뉘어 진다.</li>
<li>Message ID: 메시지 재전송 시 중복여부를 확인하기 위한 ID</li>
</ul>
<p>위와 같이 총 4bytes(32bits)가 고정 헤더이고, token length(TKL) 값에 따라 추가적인 token 필드가 추가된다. Token 필드 뒤에는 option 필드들이 붙는다.
Option 필드는 DHCP의 option 필드와 유사하게 TLV(type-length-value) 형태이나, 크기를 최대한 줄이기 위하여 독특한 방법을 사용하였다. Option 번호(Type)는 크기를 줄이기 위하여 이전 option 값과의 차이를 기록한다. 즉, 이전 option type 이 3 이 었고, 이번 option 이 10이라면 Option delta에는 7을 기록 한다.</p>
<p><img class=lazyload data-src=coap-payload.png data-srcset="/posts/coap-protocol/coap-payload.png, coap-payload.png 1.5x, /posts/coap-protocol/coap-payload.png 2x" data-sizes=auto alt=/posts/coap-protocol/coap-payload.png title="CoAP Payload"></p>
<ul>
<li>Option Delta: Option delta의 경우도 크기를 줄이기 위하여 0~12는 그대로 이 필드에 기록을 하고, 이 보다 증분이 클때는 13,14 값을 적는다. 이 경우 확장된 Option Delta가 추가로 붙고, 이 확장 필드의 크기는 13인 경우 1bytes, 14인 경우 2bytes가 된다. Option Delta는 0이나 양수이므로 옵션 필드의 순서는 정렬된 순서로 패킷에 들어가야 한다.</li>
<li>Option Length: Option length도 option delta와 동일하게 0~12는 이 필드만 사용하고, 13,14인 경우에는 각각 1, 2bytes의 Option Length(extended)필드가 추가된다.</li>
</ul>
<p>최종적인 Option 항목의 끝은 1 byte의 0xff 값을 가진 payload marker가 들어간다. 이 payload marker 이후는 전송할 데이타이 payload가 들어간다.</p>
<p>프로토콜 상에서는 전체 패킷의 크기를 위한 필드가 없다. 이와 같은 이유는 datagram으로 보내기 때문에 항상 앞의 header 정보를 제외한 나머지를 모두 payload로 처리한다. 이것도 크기를 줄이기 위한 것이다.</p>
<p>여기에 6LoWPAN은 link-local address (single hop) 인 경우 IPv6는 2 octets, UDP는 4 octets로 헤더압축이 되고, DTLS도 7bytes payload가 최대 127 octets인 802.15.4 에서도 fragmentation없이 데이터 전송이 가능하다.</p>
<h3 id=메시지-전송>메시지 전송</h3>
<p>HTTP의 request method와 response code는 헤더의 Code 필드를 이용한다. 위에서도 설명하였듯이 8bits의 Code 필드는 3bits.5bits 로 나뉘어 지고, 이를 중간에 .(점)을 넣어 표기한다. 예를 들어 이진수로 100.00001b은 4.01 ‘Unauthorized’ 코드가 된다.
앞부분의 3bit가 response class로 HTTP와 동일하게 2는 성공, 4는 client error, 5는 server error가 된다. 그리고 0은 method 용도로 다음과 같이 정의된다.</p>
<ul>
<li>0.01: GET</li>
<li>0.02: POST</li>
<li>0.03: PUT</li>
<li>0.04: DELETE</li>
</ul>
<p>이 8bits code 필드로 이와 같이 구분하면 HTTP와 유사한 형태의 request-response 메시지를 정의할 수 있다.</p>
<p>CoAP은 기본적으로 UDP를 사용하기 때문에 request에 대한 response 응답이 없는 경우 일정 시간 후 request 측에서 재전송 하여야 한다. 이 경우 수신측에서 중복된 메시지 인지를 구분할 수 있도록 Token 필드를 이용한다.</p>
<p>하지만 request에 대하여 응답이 길어지는 경우가 있는 경우 이 방식으로는 문제가 있다. 예를 들어 온도 측정을 요청했는데, 기기에서 온도 값을 얻는데 10초이상 소요될 수도 있다. CoAP에서는 응답이 없는 경우 재전송 주기는 2초이다. 이렇게 응답이 늦어지는 경우 송신측에서는 response가 올때까지 계속 재전송을 하여야 한다. 수신측이야 Token 필드를 이용하여 중복된 메시지 인지를 구분하여 한번의 응답만 가도록 할 수 있으나, 송신측에서는 수신측이 받았는지, 않받았는지를 확인할 방법이 없다.
이와 같은 수신여부를 확인하기 위하여 Type(T)과 Message ID 필드를 사용한다. Type 필드가 0인 경우에는 confirmable로 수신측은 필드값 2로 ACK 응답을 하여야 한다.</p>
<p>일반적인 경우에는 ACK 응답시 아래 처럼 CoAP response message 를 보낸다(piggybacked).</p>
<p><img class=lazyload data-src=coap-flow1.png data-srcset="/posts/coap-protocol/coap-flow1.png, coap-flow1.png 1.5x, /posts/coap-protocol/coap-flow1.png 2x" data-sizes=auto alt=/posts/coap-protocol/coap-flow1.png title="CoAP flow 1"></p>
<p>만일 수신측에서 바로 응답을 할 수 없는 경우에는 아래처럼 ACK 응답만 먼저하고, 나중에 request에 대한 response를 할 수 있다.
Message ID(MID)는 confirmable-ack transaction 단위로만 사용하여, 아래와 같은 경우에는 response 시에는 다른 MID를 사용하여야 한다.</p>
<p><img class=lazyload data-src=coap-flow2.png data-srcset="/posts/coap-protocol/coap-flow2.png, coap-flow2.png 1.5x, /posts/coap-protocol/coap-flow2.png 2x" data-sizes=auto alt=/posts/coap-protocol/coap-flow2.png title="CoAP flow 2"></p>
<p>위의 예에서 response 시에도 Type(T)필드를 Confirmable(CON)로 요청을 해서 ACK를 받았는데, 이 부분은 Confirmable로 응답할 지, Non-confirmable로 응답할 지는 수신측 마음이다.</p>
<p>Reset Type(T) 필드는 잘못된 응답을 받았을 때 상대방에게 알려주기 위한 것이다.</p>
<p>이와 같이하여 UDP 상에서 효율은 떨어지지만 TCP와 유사한 reliability를 제공할 수 있다.</p>
<h3 id=cache--proxy>Cache & Proxy</h3>
<p>제한된 성능의 종단 노드를 대신하여 border gateway에서 어느정도 cache를 해줄 수도 있다. 예를 들어 한번 온도 센서에서 온도값을 읽어오면 일정 시간 내에서는 다시 종단 노드에게 물어보는 것이 아니라 기존에 cache된 값을 사용할 수 있다.</p>
<p>이 부분은 option 필드의 Max-Age와 ETag를 사용한다. 이를 사용하는 예는 아래와 같다.
(아래 그림은 ‘<a href=https://www.iab.org/wp-content/IAB-uploads/2011/04/Shelby.pdf target=_blank rel="noopener noreffer">Introduction to Resource-Oriented Applications in Constrained Networks</a>’ 에서 발췌)</p>
<p><img class=lazyload data-src=coap-proxy.png data-srcset="/posts/coap-protocol/coap-proxy.png, coap-proxy.png 1.5x, /posts/coap-protocol/coap-proxy.png 2x" data-sizes=auto alt=/posts/coap-protocol/coap-proxy.png title="CoAP Proxy"></p>
<h3 id=observation>Observation</h3>
<p>Polling 이 아니라 event 방식을 이용하는 것도 Observe option 필드를 이용하여 지원한다.</p>
<p><img class=lazyload data-src=coap-observation.png data-srcset="/posts/coap-protocol/coap-observation.png, coap-observation.png 1.5x, /posts/coap-protocol/coap-observation.png 2x" data-sizes=auto alt=/posts/coap-protocol/coap-observation.png title="CoAP Observation"></p>
<h2 id=마치며>마치며</h2>
<p>이 외에도 큰 사이즈 데이타 전송을 위한 black transfer도 지원하고, multicast address를 이용한 여러 소스에서 응답 받기, service/resource discovery 도 지원하여 별도의 설정없이 자동으로 시스템 구성도 할 수 있다.</p>
<p>Zigbee 보다는 좀더 오픈 마인드로 <a href=http://threadgroup.org/ target=_blank rel="noopener noreffer">Thread</a> 그룹에서 802.15.4, 6LoWPAN, CoAP 등 오픈 표준을 통합하여 표준화 정의 및 호환성 검증을 하기 때문에 센서 네트워크에서 CoAP 이 업계 표준 프로토콜로 자리잡을 가능성은 상당히 커 보인다.</p>
<p>무엇보다도 CoAP 의 장점으로 볼 수 있는 것은 IP 기반이라는 것이다. HTTP나 <a href=https://www.ietf.org/rfc/rfc3261.txt target=_blank rel="noopener noreffer">SIP</a> 처럼 IP 기반으로 proxy 로 확장을 할 수 있는 구조로, 기존 Gateway방식의 센서 네트워크를 꾸미는 것보다 다음과 같은 면에서 장점이 있을 것이다.</p>
<ul>
<li>보안: 순순한 IP 망이면 end-to-end 암호화도 가능하므로 중간의 proxy를 신뢰도가 낮아도 됨. Gateway 방식은 IP 네트워크와 센서 네트워크간의 데이타 변환을 위하여 복호화 수행하므로 보안 레벨이 높아야 함.</li>
<li>확장성: Proxy는 stateless로도 운영 가능하며 변경없이 새로운 서비스 적용 가능</li>
<li>투명성: 순수 IPv6 네트워크</li>
</ul>
<p>(연말에다 프로젝트 마감으로 인하여 문서 작성이 늦어서 급히 마무리 짓느라 뒷 부분이 좀 부실한 것 같아 아쉬움이.. 다음에 좀더 보완을 해 보아야겠다)</p>
</div>
<div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>Updated on 2016-12-14</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md></div>
<div class=post-info-share>
<span></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/coap/>CoAP</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span>
</section>
</div>
<div class=post-nav><a href=/posts/mqtt-protocol/ class=prev rel=prev title="MQTT Protocol"><i class="fas fa-angle-left fa-fw"></i>MQTT Protocol</a>
<a href=/posts/how-to-make-sdcard-disk-image/ class=next rel=next title="SD card 디스크 이미지 만들고 수정하는 방법 정리">SD card 디스크 이미지 만들고 수정하는 방법 정리<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id=comments><div id=giscus></div><noscript>
Please enable JavaScript to view the comments powered by <a href=https://giscus.app/>giscus</a>.
</noscript></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://www.humminglab.io target=_blank rel="noopener noreferrer">HummingLab</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
</div></footer></div>
<div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top">
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments">
<i class="fas fa-comment fa-fw"></i>
</a>
</div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-Z6SNWCXRNY',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-Z6SNWCXRNY" async></script></div>
<div class=pjax-assets><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{giscus:{darkTheme:"dark",dataCategory:"Announcements",dataCategoryId:"DIC_kwDOGdk00s4CAGXN",dataEmitMetadata:"0",dataMapping:"pathname",dataReactionsEnabled:"1",dataRepo:"humminglab/blog.humminglab.io",dataRepoId:"R_kgDOGdk00g",lightTheme:"light"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/katex/katex.min.css>
<noscript><link rel=stylesheet href=/lib/katex/katex.min.css></noscript><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/katex/copy-tex.min.css>
<noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript></div>
</body>
</html>