<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title class=pjax-title>TLS/암호 알고리즘 쉽게 이해하기(12) - ECDH, ECDSA - All about IoT</title><meta name=Description content><meta property="og:title" content="TLS/암호 알고리즘 쉽게 이해하기(12) - ECDH, ECDSA"><meta property="og:description" content="이전 글 Elliptic Curve Cryptography(ECC)에서는 타원곡선 암호의 특징 및 알고리즘을 알아보았다.
이번에는 이를 활용한 암호화 응용과 실제 사용 예를 살펴보기로 한다.
ECC vs. RSA 공개키 암호화 방법으로 RSA와 비교하여 이야기 되나, 실제적으로 ECC는 RSA와 동일한 기능으로 사용하지는 않는다.
정확히는 RSA가 아니라 이산대수 문제를 이용한 DH 나 DSA 용도로 사용한다고 말할 수 있다.
RSA의 경우 아래와 같이 평문 $k$ 를 공개키 $e$로 모듈러 지수 연산을 하는 형식이다.
$$ E = k^e \pmod{n} $$"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.humminglab.io/posts/tls-cryptography-12-ecc2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-19T13:00:00+09:00"><meta property="article:modified_time" content="2022-04-20T10:00:00+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="TLS/암호 알고리즘 쉽게 이해하기(12) - ECDH, ECDSA"><meta name=twitter:description content="이전 글 Elliptic Curve Cryptography(ECC)에서는 타원곡선 암호의 특징 및 알고리즘을 알아보았다.
이번에는 이를 활용한 암호화 응용과 실제 사용 예를 살펴보기로 한다.
ECC vs. RSA 공개키 암호화 방법으로 RSA와 비교하여 이야기 되나, 실제적으로 ECC는 RSA와 동일한 기능으로 사용하지는 않는다.
정확히는 RSA가 아니라 이산대수 문제를 이용한 DH 나 DSA 용도로 사용한다고 말할 수 있다.
RSA의 경우 아래와 같이 평문 $k$ 를 공개키 $e$로 모듈러 지수 연산을 하는 형식이다.
$$ E = k^e \pmod{n} $$"><meta name=application-name content="All about IoT"><meta name=apple-mobile-web-app-title content="All about IoT"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://blog.humminglab.io/posts/tls-cryptography-12-ecc2/><link rel=prev href=https://blog.humminglab.io/posts/tls-cryptography-11-ecc/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"TLS/암호 알고리즘 쉽게 이해하기(12) - ECDH, ECDSA","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.humminglab.io\/posts\/tls-cryptography-12-ecc2\/"},"genre":"posts","keywords":"Cryptography, ECC, ECDH, ECDSA","wordcount":1670,"url":"https:\/\/blog.humminglab.io\/posts\/tls-cryptography-12-ecc2\/","datePublished":"2022-04-19T13:00:00+09:00","dateModified":"2022-04-20T10:00:00+09:00","publisher":{"@type":"Organization","name":"HummingLab"},"authors":[{"@type":"Person","name":"YSLee"}],"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e)}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(t){const e=document.getElementsByTagName("meta");for(let n=0;n<e.length;n++)if(e[n].getAttribute("name")===t)return e[n];return''}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?setTheme("dark"):setTheme("light")}else''==="light"||''==="dark"||''==="black"?(setTheme(''),saveTheme('')):(saveTheme("auto"),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?setTheme("dark"):setTheme("light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")]</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="All about IoT">All about IoT</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=https://www.humminglab.io/ rel="noopener noreffer" target=_blank>HummingLab </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="All about IoT">All about IoT</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=https://www.humminglab.io/ title rel="noopener noreffer" target=_blank>HummingLab</a><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class="toc-content always-active" id=toc-content-auto></div></div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">TLS/암호 알고리즘 쉽게 이해하기(12) - ECDH, ECDSA</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.humminglab.io/authors/yslee>YSLee</a></span>
</span>&nbsp;<span class=post-category>included in </span>&nbsp;<span class=post-category>category <a href=/categories/security/><i class="far fa-folder fa-fw"></i>Security</a></span>&nbsp;<span class=post-category>and</span>&nbsp;<span class=post-series>series <a href=/series/tls/%EC%95%94%ED%98%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/><i class="far fa-list-alt fa-fw"></i>TLS/암호 알고리즘 쉽게 이해하기</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-04-19>2022-04-19</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2022-04-20>2022-04-20</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1670 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;8 minutes&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#ecc-vs-rsa>ECC vs. RSA</a></li><li><a href=#ecdh-키교환>ECDH 키교환</a></li><li><a href=#ecdsa>ECDSA</a></li><li><a href=#타원곡선의-종류>타원곡선의 종류</a></li><li><a href=#타원곡선-선정>타원곡선 선정</a></li><li><a href=#openssl-로-동작-확인>Openssl 로 동작 확인</a><ul><li><a href=#ecdh-시험>ECDH 시험</a></li><li><a href=#ecdsa-시험>ECDSA 시험</a></li></ul></li><li><a href=#마치며>마치며</a></li></ul></nav></div></div><div class=content id=content><p>이전 글 <a href=https://blog.humminglab.io/posts/tls-cryptography-11-ecc/ rel>Elliptic Curve Cryptography(ECC)</a>에서는 타원곡선 암호의 특징 및 알고리즘을 알아보았다.</p><p>이번에는 이를 활용한 암호화 응용과 실제 사용 예를 살펴보기로 한다.</p><h2 id=ecc-vs-rsa>ECC vs. RSA</h2><p>공개키 암호화 방법으로 <a href=https://blog.humminglab.io/posts/tls-cryptography-8-rsa/ rel>RSA</a>와 비교하여 이야기 되나, 실제적으로 ECC는 RSA와 동일한 기능으로 사용하지는 않는다.</p><p>정확히는 RSA가 아니라 이산대수 문제를 이용한 <a href=https://blog.humminglab.io/posts/tls-cryptography-7-diffie-hellman/ rel>DH</a> 나
<a href=https://blog.humminglab.io/posts/tls-cryptography-9-dsa/ rel>DSA</a> 용도로 사용한다고 말할 수 있다.</p><p>RSA의 경우 아래와 같이 평문 $k$ 를 공개키 $e$로 모듈러 지수 연산을 하는 형식이다.</p><p>$$ E = k^e \pmod{n} $$</p><p>ECC의 경우 평문이 아닌 순환되는 subgroup 이 좋은 generator $G$를 선정하여 이를 키 $e$ 로 곱하는 것이다.
$$ E = eG \pmod{p} $$</p><p>즉, 평문을 암호화 하는 용도로는 사용하지 않는다. 물론 RSA의 경우도 일반 평문을 암호화 하게 되면 분석적인 공격에 취약해질 가능성이 있으므로,
hash 결과 값(서명 시)이나, 랜덤하게 만들어진 키 교환 등의 용도로만 사용을 권장한다.</p><h2 id=ecdh-키교환>ECDH 키교환</h2><p><a href=https://blog.humminglab.io/posts/tls-cryptography-7-diffie-hellman/ rel>Diffie-Hellman Key Exchange</a> 에서는 이산대부 문제인 모듈러 지수 연산의 어려움을 이용한 키교환 방법이었다.</p><p>이 지수 연산을 타원곡선의 곱하기 연산으로 대체한 것이 ECDH(Elliptic-curve Diffie–Hellman) 이다.</p><p>키교환 절차는 다음과 같다.</p><ul><li>Alice 와 Bob은 우선 domain prameter인 다음 값들을 교환한다. 이는 다른 사람들이 볼수도 있다.<ul><li>p: 모듈러 값</li><li>G: Generator</li><li>a, b: 타원 곡선의 a, b 값</li></ul></li><li>Alice는 자신의 비밀키 $d_a$ 를 선택하고, 공개키 $H_a = d_a G$ 를 계산하여 Bob에게 전달</li><li>Bob도 자신의 비밀키 $d_b$ 를 선택하고, 공개키 $H_b = d_b G$ 를 계산하여 Alice에게 전달</li><li>Alice와 Bob은 다음과 같이 키 S를 찾아냄<ul><li>$S = d_a H_b = d_a(d_b G) = d_b (d_a G) = d_b H_a$</li></ul></li><li>공격자는 G, p, a, b를 알고, $H_a, H_b$ 를 얻는다고 해도 이를 풀수 있는 방법이 없다.</li></ul><p>더하기 연산으로 표시되니까 오히려 DH 보다 이햐하기가 편하다.</p><h2 id=ecdsa>ECDSA</h2><p><a href=https://blog.humminglab.io/posts/tls-cryptography-9-dsa/ rel>DSA</a>에서 서명으로 힌트인 $r$ 값과 문서의 hash 값인 $x$가 포함된 $s$ 값을 서명값으로 사용하는 것이었다.</p><p>$$
\begin{align*}
r &\equiv (\alpha^k \pmod p) \pmod q \\
s &\equiv \overline{k} (x + zr) \pmod q
\end{align*}
$$</p><p>ECDSA도 기본 골자는 비슷하다.</p><p>서명을 할 Alice는 domain parameter인 (G, p, a, b)를 정하고, 자신의 비밀키 $d_a$를 선택하고, 이를 이용하여 공개키 $H_a = d_a G$ 를 계산한다.</p><ul><li>개인키는 $d_a$ 공개되지 않는다.</li><li>Domain paramter (G, p, a, b) 와 공개키 $H_a$는 공개된다.</li></ul><p>Alice 다음과 같이 서명한다.</p><ul><li>1~$p$ 사이의 랜덤한 정수 $k$를 선택한다.</li><li>$P = kG$를 계산한다.</li><li>$P$ 값은 $(x_p, y_p)$ 포인트로 구성되는데 이 중 $x_p$를 이용하여 $r$을 계산한다.<ul><li>$r \equiv x_p \pmod {p}$</li><li>만일 $r=0$ 이면 다른 $k$를 선택하여 재계산 한다.</li></ul></li><li>서명을 위한 hash 값은 $z$ 를 포함하여 다음 연산으로 $s$를 계산한다. 만일 hash 값 $z$가 $p$ 보다 크면 $p$의 비트 길이만 사용하고 상위는 버린다.<ul><li>$s \equiv \overline{k} (z + r d_a) \pmod {p}$</li><li>마찬가지로 $s=0$ 이면 다른 $k$를 선택하여 재계산 한다.</li></ul></li><li>$(r, s)$를 서명값으로 배포한다.</li></ul><p>위 식에서 만일 subgroup order 가 소수가 아니면 위식을 사용할 수 없어, 키 선정 시 소수를 사용한다.</p><p>Bob 은 다음과 같이 검증한다.</p><ul><li>다음 세 연산을 수행한다.<ul><li>$u_1 \equiv \overline{s}z \pmod p$</li><li>$u_2 \equiv \overline{s}r \pmod p$</li><li>$P = u_1 G + u_2 H_a$</li></ul></li><li>위의 결과값 $P (x_p, y_p)$ 중 $r \equiv x_p \pmod {p}$ 이면 서명이 유효하다.</li></ul><h2 id=타원곡선의-종류>타원곡선의 종류</h2><p>RSA, DH, DSA 와 같이 이산대수 문제를 이용하는 암호화 방법들은 초기 개인키를 생성하기 위하여 큰 소수를 찾는 과정이 필요하다.</p><p>마찬 가지로 타원곡선에서도 위에서 언급한 domain parameter 을 구하여야 한다. 이를 다시 정리해 보면 다음과 같다.</p><ul><li>p: 모듈러 값</li><li>G: Generator</li><li>a, b: 타원 곡선 $y^2=x^3+ax+b$ 의 a, b 값</li><li>n: order of subgroup. G를 계속 더했을때 순환하는 그룹의 개수</li><li>h: cofactor of subgroup.</li></ul><p>앞에 보다 n, h 가 추가되었는데, 이는 이전 글 <a href=https://blog.humminglab.io/posts/tls-cryptography-11-ecc/ rel>Elliptic Curve Cryptography(ECC)</a>을 참조하면 된다.</p><p>어쨋든 이들을 계산하여야 하는데, 타원곡선에서는 이산대수와는 달리 사전에 정하여진 domain paramter를 사용한다.</p><p>다음과 같이 openssl 에서 지원하고 있는 타원곡선 종류를 확인 가능하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl ecparam -list_curves
</span></span><span class=line><span class=cl>  secp112r1 : SECG/WTLS curve over a <span class=m>112</span> bit prime field
</span></span><span class=line><span class=cl>  secp112r2 : SECG curve over a <span class=m>112</span> bit prime field
</span></span><span class=line><span class=cl>  ...
</span></span><span class=line><span class=cl>  prime192v1: NIST/X9.62/SECG curve over a <span class=m>192</span> bit prime field
</span></span><span class=line><span class=cl>  prime192v2: X9.62 curve over a <span class=m>192</span> bit prime field
</span></span><span class=line><span class=cl>  ...
</span></span><span class=line><span class=cl>  sect113r1 : SECG curve over a <span class=m>113</span> bit binary field
</span></span><span class=line><span class=cl>  sect113r2 : SECG curve over a <span class=m>113</span> bit binary field
</span></span><span class=line><span class=cl>  ...
</span></span></code></pre></td></tr></table></div></div><p>예를 들어 이 중 prime192v1 의 경우 domain parameter는 다음과 같은 값이다.</p><ul><li>p: <code>0xfffffffffffffffffffffffffffffffeffffffffffffffff</code></li><li>a: <code>0xfffffffffffffffffffffffffffffffefffffffffffffffc</code></li><li>b: <code>0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1</code></li><li>G: (<code>0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012</code>, <code>0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811</code>)</li><li>n: <code>0xffffffffffffffffffffffff99def836146bc9b1b4d22831</code></li><li>h: <code>0x1</code></li></ul><p>결국은 ECDH나 ECDSA를 사용하는 경우에는 이산대수 암호화 방법과는 달리 다음과 같은 절차를 거친다.</p><ul><li>사용할 암호 강도 등을 고려하여 적절한 타원곡선을 선정 (예: prime192v1)</li><li>랜덤하게 자신의 비밀키를 선정</li></ul><p>성능이 낮은 IoT 기기에서 RSA 2048 이나 RSA 3096 의 개인키를 생성하는 것은 성능에 따라서 수 분에서 수 십분이 소요될 수도 있는데, 타원곡선의 경우 랜덤으로 개인키를 생성만 하면 되기 때문에 이 부분도 하나의 큰 장점이 될 수 있다.</p><p>그렇다면 이들 타원곡선은 어떻게 선정되는 것일까?</p><p>인위적으로 특정 parameter로 만들어진 타원곡선은 취약점을 가지고 있다고 한다. 예를 들어 $p = hn$ 인 곡선은 <a href=https://www.secmem.org/blog/2020/05/19/Anomalous-Elliptic-Curve/ target=_blank rel="noopener noreffer">Smart&rsquo;s attack</a> 으로 쉽게 풀릴수 있다고 한다. 의도적으로 이런 취약점을 가진 곡선을 만드는 것을 막는 방법 중 하나로 타원 곡선의 parameter a,b 선정 시 다음과 같은 방법을 이용하기도 한다.</p><figure><img src=random-parameters-generation.png alt="Paramter a, b 결정방법" width=500px height=auto><figcaption><p>Paramter a, b 결정방법</p></figcaption></figure><p>이와 같이 random seed를 hash 함수를 이용하여 최종적으로 만들어진 a, b를 사용하도록 한다면 이와 같은 의도성을 막을 수 있다. 보통 이 hash 함수로 SHA-1 을 사용한다.</p><p>이제 각 타원곡선이 어떻게 만들어 졌는지 찾아보자.
아래 링크를 보면 사용하고 있는 모든 타원곡선에 대해서 정보를 얻을 수 있다.</p><ul><li><a href=https://neuromancer.sk/std/ target=_blank rel="noopener noreffer">Standard curve database</a></li></ul><p>예를 들어 prime192v1는 다음과 같이 정보를 얻을 수 있다.</p><ul><li>ANSI X9.62 표준으로 정의된 prime192v1 의 정보는 아래 링크에 있다.<ul><li><a href=https://neuromancer.sk/std/x962/prime192v1 target=_blank rel="noopener noreffer">prime192v1</a></li></ul></li><li>상단에는 위 domain paramter 값들을 확인할 수 있고, 그 아래에 Seed 값이 명기되어 있다. 이 Seed 값을 이용하여 a, b 가 선정된 것이다.<ul><li>Seed: <code>3045AE6FC8422F64ED579528D38120EAE12196D5</code></li></ul></li><li>Seed 값으로 SHA-1 hash로 a, b를 구하는 방법은 아래 링크에서 확인할 수 있다.<ul><li><a href=https://neuromancer.sk/std/methods/x962/ target=_blank rel="noopener noreffer">Method - ANSI X9.62</a></li></ul></li></ul><p>타원곡선에 따라서 domain parameters를 선정하는 방식은 다르지만, 사용 방법은 지정된 domain parameter를 이용하여 동일하다.</p><h2 id=타원곡선-선정>타원곡선 선정</h2><p><a href=https://neuromancer.sk/std/ target=_blank rel="noopener noreffer">Standard curve database</a> 보면 종류가 많은데, 이중 어느 것을 사용할지 고민이 될 수 있다.</p><p>일단 <a href=https://www.keylength.com/en/4/ target=_blank rel="noopener noreffer">NIST Recommendatations (2020)</a>을 참고하면 160bit 이하의 타원곡선은 사용하여서는 안된다.
다음과 같은 곡선들이 이에 해당한다.</p><ul><li>secp112r1, secp112r2, secp128r1, secp128r2, secp160k1, secp160r1, secp160r2, secp192k1</li></ul><p>2018년 글이기는 하나 아래 링크를 참고할 만도 한다.</p><ul><li><a href=https://malware.news/t/everyone-loves-curves-but-which-elliptic-curve-is-the-most-popular/17657/1 target=_blank rel="noopener noreffer">Everyone Loves Curves! But Which Elliptic Curve is the Most Popular?</a></li></ul><p>이를 보면 다음 순으로 많이 사용한다고 한다.</p><ul><li>P-256 (secp256r1, prime256v1)</li><li>X25519</li><li>P-512 (secp512r1)</li><li>P-384 (secp384r1)</li></ul><p>256bit인 P-256 을 현 시점에서 가장 많이 사용한다.</p><p><a href=https://blog.humminglab.io/posts/tls-cryptography-3-block-cipher/ rel>Block Cipher</a>의 &lsquo;암호화 키 길이&rsquo;에 정리한 것과 같이 P-256이면 AES 128, RSA-3072와 유사한 암호화 강도를 가진 것이다.
이를 다시 정리해 보면 다음과 같다.</p><table><thead><tr><th>계열</th><th>암호시스템</th><th>80bit</th><th>128bit</th><th>192bit</th><th>256bit</th></tr></thead><tbody><tr><td>인수분해</td><td>RSA</td><td>1024</td><td>3072</td><td>7680</td><td>15360</td></tr><tr><td>이산대수</td><td>DHKE, DSA, Elgamal</td><td>1024</td><td>3072</td><td>7680</td><td>15360</td></tr><tr><td>타원곡선</td><td>ECDH, ECDSA</td><td>160</td><td>256</td><td>384</td><td>512</td></tr><tr><td>대칭암호</td><td>AES</td><td>80</td><td>128</td><td>192</td><td>256</td></tr></tbody></table><p>P-256, secp256r1, prime256v1 은 모두 동일한 것을 말하는 것으로 표준을 정리한 곳에 따라서 이름이 다르다. 관련 테이블은 아래 링크를 참고 할 수 있다.</p><ul><li><a href=https://tools.ietf.org/search/rfc4492#appendix-A target=_blank rel="noopener noreffer">RFC 4492 - Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)</a></li></ul><table><thead><tr><th>SECG</th><th>ANSI X9.62</th><th>NIST</th></tr></thead><tbody><tr><td>secp192r1</td><td>prime192v1</td><td>NIST P-192</td></tr><tr><td>secp224r1</td><td></td><td>NIST P-224</td></tr><tr><td>secp256r1</td><td>prime256v1</td><td>NIST P-256</td></tr><tr><td>secp384r1</td><td></td><td>NIST P-384</td></tr><tr><td>secp521r1</td><td></td><td>NIST P-521</td></tr></tbody></table><p><a href=https://cr.yp.to/ecdh.html target=_blank rel="noopener noreffer">X25519</a> 는 <a href=https://www.iacr.org/cryptodb/archive/2006/PKC/3351/3351.pdf target=_blank rel="noopener noreffer">Curve25519</a> 타원함수를 사용하는 것으로 ECDH는 X25519, ECDSA는 <a href=https://ed25519.cr.yp.to target=_blank rel="noopener noreffer">ED25519</a> 라고 한다.</p><p>P-256은 NIST 에서 정의한 것이라 많이 사용하는 이유는 명확한데, X25519를 많이 사용하는 이유는 다음과 같다고 한다.</p><ul><li>설계자인 Daniel J. Bernstein (DJB)가 소스 및 관련 자료를 아래 링크에 공개하였고, 특허도 없고, timing attack에도 안전하도록 설계하였다.<ul><li><a href=https://cr.yp.to/ecdh.html target=_blank rel="noopener noreffer">A state-of-the-art Diffie-Hellman function</a></li></ul></li><li>IETF TLS 1.3에 X25519, ED25519가 추가되었고, NIST에서도 2017년에 <a href=https://csrc.nist.gov/CSRC/media/Publications/sp/800-186/draft/documents/sp800-186-draft-comments-received.pdf target=_blank rel="noopener noreffer">Special Publication SP 800-186</a> 에 추가되어서, 미정부에서 사용도 승인되었다.</li><li>P-256에 비교하여 40% 정도 연산량이 적어, 특히 저사양 CPU를 사용하는 IoT 기기에 좋다.</li><li>많은 브라우저나 TLS 업체에서 지원한다.</li></ul><p>OpenSSL command line에서는 아직은 Curve25519를 지원하지 않아 genpkey 명령으로 직접 만들어서 사용하여야 한다.</p><ul><li><a href=https://wiki.openssl.org/index.php/Command_Line_Elliptic_Curve_Operations#Generating_EC_Keys_and_Parameters target=_blank rel="noopener noreffer">https://wiki.openssl.org/index.php/Command_Line_Elliptic_Curve_Operations#Generating_EC_Keys_and_Parameters</a></li></ul><p>이상으로 정리해 보면 다음과 같이 사용하면 될 것 같다.</p><ul><li>일반적인 용도라면 P-256 사용</li><li>보안 강도를 높일 필요가 있다면 P-512 사용</li><li>IoT 기기 등 저사양을 고려한다면 X25519, ED25519 사용</li></ul><p>IoT 기기에서 사용하여 X25519, ED25519를 사용한다면 <a href=https://libsodium.gitbook.io/doc/advanced/ed25519-curve25519 target=_blank rel="noopener noreffer">libsodium</a> 등의 library를 사용할 수 있다.</p><h2 id=openssl-로-동작-확인>Openssl 로 동작 확인</h2><h3 id=ecdh-시험>ECDH 시험</h3><p>Openssl을 이용하여 ECDH를 확인 해본다.</p><ul><li>우선 지원되는 curve를 확인한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl ecparam -list_curves
</span></span></code></pre></td></tr></table></div></div><ul><li>ecparam subcommand로 Alice의 개인키를 생성한다. 여기에서는 P-256 (prime256v1)을 생성하였다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl ecparam -name prime256v1 -genkey -noout -out alice-priv.pem
</span></span></code></pre></td></tr></table></div></div><ul><li>생성된 개인키는 다음과 같이 확인 가능하다.<ul><li>Private key는 랜덤하게 생성된 것으로 이 경우 256bit의 길이가 맞다.</li><li>Public key의 경우 private 보다 약 2배 가량 되는데, 이유는 위에서 처럼 $H_a = d_a G$ 와 같이 x,y 좌표를 가진 Genearator G와 곱한 결과인 x, y 좌표와 1bit의 parity 가 추가되었기 때문이다.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl ec -in alice-priv.pem -text -noout
</span></span><span class=line><span class=cl><span class=nb>read</span> EC key
</span></span><span class=line><span class=cl>Private-Key: <span class=o>(</span><span class=m>256</span> bit<span class=o>)</span>
</span></span><span class=line><span class=cl>priv:
</span></span><span class=line><span class=cl>    1c:6d:99:e3:18:fa:78:0e:9e:08:a7:81:95:49:0c:
</span></span><span class=line><span class=cl>    e5:b3:6e:26:7b:40:76:94:c3:79:74:50:98:cd:db:
</span></span><span class=line><span class=cl>    f4:bf
</span></span><span class=line><span class=cl>pub:
</span></span><span class=line><span class=cl>    04:c0:00:72:22:80:b6:27:12:78:4e:a2:9c:1f:6b:
</span></span><span class=line><span class=cl>    3c:e5:96:b2:24:94:59:3c:a0:5f:64:36:ef:f4:1b:
</span></span><span class=line><span class=cl>    32:34:38:e1:cf:84:9a:ed:08:27:30:ee:6c:08:13:
</span></span><span class=line><span class=cl>    32:c5:0c:96:fc:1a:99:97:f2:d5:5c:5f:bc:fd:b9:
</span></span><span class=line><span class=cl>    ed:f5:6d:a9:8e
</span></span><span class=line><span class=cl>ASN1 OID: prime256v1
</span></span><span class=line><span class=cl>NIST CURVE: P-256
</span></span></code></pre></td></tr></table></div></div><ul><li>개인키로 공개키를 생성한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl ec -in alice-priv.pem -pubout -out alice-pub.pem
</span></span></code></pre></td></tr></table></div></div><ul><li>동일한 방식으로 Bob의 개인키와 공개키를 생성한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl ecparam -name prime256v1 -genkey -noout -out bob-priv.pem
</span></span><span class=line><span class=cl>$ openssl ec -in bob-priv.pem -pubout -out bob-pub.pem
</span></span></code></pre></td></tr></table></div></div><ul><li><p>Alice와 Bob은 prime256v1 타원곡선 정보와 각자 자신의 공개키를 상대방에게 전달하였다고 하자.</p></li><li><p>Alice는 Bob의 공개키를 이용하여 키를 유도할 수 있다.</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl pkeyutl -derive -out alicebob.key -inkey alice-priv.pem -peerkey bob-pub.pem
</span></span></code></pre></td></tr></table></div></div><ul><li>Bob도 Alice의 공개키를 이용하여 키를 유도할 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl pkeyutl -derive -out bobalice.key -inkey bob-priv.pem -peerkey alice-pub.pem
</span></span></code></pre></td></tr></table></div></div><ul><li>둘이 생성한 키 값을 비교하면 아래와 같이 동일한 것을 알수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ hexdump alicebob.key
</span></span><span class=line><span class=cl><span class=m>0000000</span> f5d1 d9f7 cb35 be15 51af d264 b90f 4bb7
</span></span><span class=line><span class=cl><span class=m>0000010</span> c031 dae3 ed42 71c4 f3b1 c0a5 42f1 <span class=m>7955</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ hexdump bobalice.key
</span></span><span class=line><span class=cl><span class=m>0000000</span> f5d1 d9f7 cb35 be15 51af d264 b90f 4bb7
</span></span><span class=line><span class=cl><span class=m>0000010</span> c031 dae3 ed42 71c4 f3b1 c0a5 42f1 <span class=m>7955</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=ecdsa-시험>ECDSA 시험</h3><p>위에서 생성한 Alice의 키를 이용하여 서명을 해본다.</p><ul><li>서명할 파일 생성</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=m>1234567890</span> &gt; mydata.txt
</span></span></code></pre></td></tr></table></div></div><ul><li>dgst subcommand로 SHA-256 해시함수를 사용하여 서명한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl dgst -sha256 -sign alice-priv.pem -out mydata.sha256 mydata.txt
</span></span></code></pre></td></tr></table></div></div><ul><li>서명파일은 DER 인코딩 된 것으로 asn1parse 로 확인하면 다음과 같이 256bit의 두 값 r 과 s가 차례대로 들어 있는 것을 확인할 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl asn1parse -in mydata.sha256 -inform DER
</span></span><span class=line><span class=cl>    0:d<span class=o>=</span><span class=m>0</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>  <span class=m>68</span> cons: SEQUENCE
</span></span><span class=line><span class=cl>    2:d<span class=o>=</span><span class=m>1</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>  <span class=m>32</span> prim: INTEGER           :56E84F9DC7396284C9E03B78DF1AE024E5EE86051EAC52AB02B940A861A5C62F
</span></span><span class=line><span class=cl>   36:d<span class=o>=</span><span class=m>1</span>  <span class=nv>hl</span><span class=o>=</span><span class=m>2</span> <span class=nv>l</span><span class=o>=</span>  <span class=m>32</span> prim: INTEGER           :78831E8F60EE73AD23DFB43E5A460A5ADB4A75C49CA5AAEA49ACEE37D94C5C36
</span></span></code></pre></td></tr></table></div></div><ul><li>서명 검증은 alice의 공개키를 이용하여 할 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ openssl dgst -sha256 -verify alice-pub.pem -signature mydata.sha256 mydata.txt
</span></span><span class=line><span class=cl>Verified OK
</span></span></code></pre></td></tr></table></div></div><h2 id=마치며>마치며</h2><p>지금까지 정리한 사항으로 대칭키, 비대칭키 암호, 해시, 키 합의, 서명 등 암호화의 기본이 기능이 정리된 것 같다.</p><p>다음에는 이들을 조합하여 인증 방식 및 TLS 표준을 정리할 예정이다.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-04-20</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/cryptography-ecc-ecdh-ecdsa/>Cryptography, ECC, ECDH, ECDSA</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/tls-cryptography-11-ecc/ class=prev rel=prev title="TLS/암호 알고리즘 쉽게 이해하기(11) - Elliptic Curve Cryptography(ECC)"><i class="fas fa-angle-left fa-fw"></i>TLS/암호 알고리즘 쉽게 이해하기(11) - Elliptic Curve Cryptography(ECC)</a></div></div><div id=comments><div id=giscus></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/>giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://www.humminglab.io target=_blank rel="noopener noreferrer">HummingLab</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-83257319-3",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-83257319-3" async></script></div><div class=pjax-assets><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{giscus:{darkTheme:"dark",dataCategory:"Announcements",dataCategoryId:"DIC_kwDOGdk00s4CAGXN",dataEmitMetadata:"0",dataMapping:"pathname",dataReactionsEnabled:"1",dataRepo:"humminglab/blog.humminglab.io",dataRepoId:"R_kgDOGdk00g",lightTheme:"light"}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/katex.min.css><noscript><link rel=stylesheet href=/lib/katex/katex.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript></div></body></html>